import { $ZodRegistry, globalRegistry } from "./registries.js";
import { getEnumValues } from "./util.js";
export class JSONSchemaGenerator {
    constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? globalRegistry;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => { });
        this.io = params?.io ?? &quot;output&quot;;
        this.seen = new Map();
    }
    process(schema, _params = { path: [], schemaPath: [] }) {
        var _a;
        const def = schema._zod.def;
        const formatMap = {
            guid: &quot;uuid&quot;,
            url: &quot;uri&quot;,
            datetime: &quot;date-time&quot;,
            json_string: &quot;json-string&quot;,
            regex: &quot;&quot;, // do not set
        };
        // check for schema in seens
        const seen = this.seen.get(schema);
        if (seen) {
            seen.count++;
            // check if cycle
            const isCycle = _params.schemaPath.includes(schema);
            if (isCycle) {
                seen.cycle = _params.path;
            }
            return seen.schema;
        }
        // initialize
        const result = { schema: {}, count: 1, cycle: undefined };
        this.seen.set(schema, result);
        if (schema._zod.toJSONSchema) {
            // custom method overrides default behavior
            result.schema = schema._zod.toJSONSchema();
        }
        // check if external
        // const ext = this.external?.registry.get(schema)?.id;
        // if (ext) {
        //   result.external = ext;
        // }
        const params = {
            ..._params,
            schemaPath: [..._params.schemaPath, schema],
            path: _params.path,
        };
        const parent = schema._zod.parent;
        // if (parent) {
        //   // schema was cloned from another schema
        //   result.ref = parent;
        //   this.process(parent, params);
        //   this.seen.get(parent)!.isParent = true;
        // }
        if (parent) {
            // schema was cloned from another schema
            result.ref = parent;
            this.process(parent, params);
            this.seen.get(parent).isParent = true;
        }
        else {
            const _json = result.schema;
            switch (def.type) {
                case &quot;string&quot;: {
                    const json = _json;
                    json.type = &quot;string&quot;;
                    const { minimum, maximum, format, patterns, contentEncoding } = schema._zod
                        .bag;
                    if (typeof minimum === &quot;number&quot;)
                        json.minLength = minimum;
                    if (typeof maximum === &quot;number&quot;)
                        json.maxLength = maximum;
                    // custom pattern overrides format
                    if (format) {
                        json.format = formatMap[format] ?? format;
                        if (json.format === &quot;&quot;)
                            delete json.format; // empty format is not valid
                    }
                    if (contentEncoding)
                        json.contentEncoding = contentEncoding;
                    if (patterns && patterns.size > 0) {
                        const regexes = [...patterns];
                        if (regexes.length === 1)
                            json.pattern = regexes[0].source;
                        else if (regexes.length > 1) {
                            result.schema.allOf = [
                                ...regexes.map((regex) => ({
                                    ...(this.target === &quot;draft-7&quot; ? { type: &quot;string&quot; } : {}),
                                    pattern: regex.source,
                                })),
                            ];
                        }
                    }
                    break;
                }
                case &quot;number&quot;: {
                    const json = _json;
                    const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                    if (typeof format === &quot;string&quot; && format.includes(&quot;int&quot;))
                        json.type = &quot;integer&quot;;
                    else
                        json.type = &quot;number&quot;;
                    if (typeof exclusiveMinimum === &quot;number&quot;)
                        json.exclusiveMinimum = exclusiveMinimum;
                    if (typeof minimum === &quot;number&quot;) {
                        json.minimum = minimum;
                        if (typeof exclusiveMinimum === &quot;number&quot;) {
                            if (exclusiveMinimum >= minimum)
                                delete json.minimum;
                            else
                                delete json.exclusiveMinimum;
                        }
                    }
                    if (typeof exclusiveMaximum === &quot;number&quot;)
                        json.exclusiveMaximum = exclusiveMaximum;
                    if (typeof maximum === &quot;number&quot;) {
                        json.maximum = maximum;
                        if (typeof exclusiveMaximum === &quot;number&quot;) {
                            if (exclusiveMaximum <= maximum)
                                delete json.maximum;
                            else
                                delete json.exclusiveMaximum;
                        }
                    }
                    if (typeof multipleOf === "number")
                        json.multipleOf = multipleOf;
                    break;
                }
                case "boolean": {
                    const json = _json;
                    json.type = "boolean";
                    break;
                }
                case "bigint": {
                    if (this.unrepresentable === "throw") {
                        throw new Error("BigInt cannot be represented in JSON Schema");
                    }
                    break;
                }
                case "symbol": {
                    if (this.unrepresentable === "throw") {
                        throw new Error("Symbols cannot be represented in JSON Schema");
                    }
                    break;
                }
                case "undefined": {
                    const json = _json;
                    json.type = "null";
                    break;
                }
                case "null": {
                    _json.type = "null";
                    break;
                }
                case "any": {
                    break;
                }
                case "unknown": {
                    break;
                }
                case "never": {
                    _json.not = {};
                    break;
                }
                case "void": {
                    if (this.unrepresentable === "throw") {
                        throw new Error("Void cannot be represented in JSON Schema");
                    }
                    break;
                }
                case "date": {
                    if (this.unrepresentable === "throw") {
                        throw new Error("Date cannot be represented in JSON Schema");
                    }
                    break;
                }
                case "array": {
                    const json = _json;
                    const { minimum, maximum } = schema._zod.bag;
                    if (typeof minimum === "number")
                        json.minItems = minimum;
                    if (typeof maximum === "number")
                        json.maxItems = maximum;
                    json.type = "array";
                    json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                    break;
                }
                case "object": {
                    const json = _json;
                    json.type = "object";
                    json.properties = {};
                    const shape = def.shape; // params.shapeCache.get(schema)!;
                    for (const key in shape) {
                        json.properties[key] = this.process(shape[key], {
                            ...params,
                            path: [...params.path, "properties", key],
                        });
                    }
                    // required keys
                    const allKeys = new Set(Object.keys(shape));
                    // const optionalKeys = new Set(def.optional);
                    const requiredKeys = new Set([...allKeys].filter((key) => {
                        const v = def.shape[key]._zod;
                        if (this.io === &quot;input&quot;) {
                            return v.optin === undefined;
                        }
                        else {
                            return v.optout === undefined;
                        }
                    }));
                    if (requiredKeys.size > 0) {
                        json.required = Array.from(requiredKeys);
                    }
                    // catchall
                    if (def.catchall?._zod.def.type === &quot;never&quot;) {
                        // strict
                        json.additionalProperties = false;
                    }
                    else if (!def.catchall) {
                        // regular
                        if (this.io === &quot;output&quot;)
                            json.additionalProperties = false;
                    }
                    else if (def.catchall) {
                        json.additionalProperties = this.process(def.catchall, {
                            ...params,
                            path: [...params.path, &quot;additionalProperties&quot;],
                        });
                    }
                    break;
                }
                case &quot;union&quot;: {
                    const json = _json;
                    json.anyOf = def.options.map((x, i) => this.process(x, {
                        ...params,
                        path: [...params.path, &quot;anyOf&quot;, i],
                    }));
                    break;
                }
                case &quot;intersection&quot;: {
                    const json = _json;
                    const a = this.process(def.left, {
                        ...params,
                        path: [...params.path, &quot;allOf&quot;, 0],
                    });
                    const b = this.process(def.right, {
                        ...params,
                        path: [...params.path, &quot;allOf&quot;, 1],
                    });
                    const isSimpleIntersection = (val) => &quot;allOf&quot; in val && Object.keys(val).length === 1;
                    const allOf = [
                        ...(isSimpleIntersection(a) ? a.allOf : [a]),
                        ...(isSimpleIntersection(b) ? b.allOf : [b]),
                    ];
                    json.allOf = allOf;
                    break;
                }
                case &quot;tuple&quot;: {
                    const json = _json;
                    json.type = &quot;array&quot;;
                    const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, &quot;prefixItems&quot;, i] }));
                    if (this.target === &quot;draft-2020-12&quot;) {
                        json.prefixItems = prefixItems;
                    }
                    else {
                        json.items = prefixItems;
                    }
                    if (def.rest) {
                        const rest = this.process(def.rest, {
                            ...params,
                            path: [...params.path, &quot;items&quot;],
                        });
                        if (this.target === &quot;draft-2020-12&quot;) {
                            json.items = rest;
                        }
                        else {
                            json.additionalItems = rest;
                        }
                    }
                    // additionalItems
                    if (def.rest) {
                        json.items = this.process(def.rest, {
                            ...params,
                            path: [...params.path, &quot;items&quot;],
                        });
                    }
                    // length
                    const { minimum, maximum } = schema._zod.bag;
                    if (typeof minimum === &quot;number&quot;)
                        json.minItems = minimum;
                    if (typeof maximum === &quot;number&quot;)
                        json.maxItems = maximum;
                    break;
                }
                case &quot;record&quot;: {
                    const json = _json;
                    json.type = &quot;object&quot;;
                    json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, &quot;propertyNames&quot;] });
                    json.additionalProperties = this.process(def.valueType, {
                        ...params,
                        path: [...params.path, &quot;additionalProperties&quot;],
                    });
                    break;
                }
                case &quot;map&quot;: {
                    if (this.unrepresentable === &quot;throw&quot;) {
                        throw new Error(&quot;Map cannot be represented in JSON Schema&quot;);
                    }
                    break;
                }
                case &quot;set&quot;: {
                    if (this.unrepresentable === &quot;throw&quot;) {
                        throw new Error(&quot;Set cannot be represented in JSON Schema&quot;);
                    }
                    break;
                }
                case &quot;enum&quot;: {
                    const json = _json;
                    const values = getEnumValues(def.entries);
                    // Number enums can have both string and number values
                    if (values.every((v) => typeof v === &quot;number&quot;))
                        json.type = &quot;number&quot;;
                    if (values.every((v) => typeof v === &quot;string&quot;))
                        json.type = &quot;string&quot;;
                    json.enum = values;
                    break;
                }
                case &quot;literal&quot;: {
                    const json = _json;
                    const vals = [];
                    for (const val of def.values) {
                        if (val === undefined) {
                            if (this.unrepresentable === &quot;throw&quot;) {
                                throw new Error(&quot;Literal `undefined` cannot be represented in JSON Schema&quot;);
                            }
                            else {
                                // do not add to vals
                            }
                        }
                        else if (typeof val === &quot;bigint&quot;) {
                            if (this.unrepresentable === &quot;throw&quot;) {
                                throw new Error(&quot;BigInt literals cannot be represented in JSON Schema&quot;);
                            }
                            else {
                                vals.push(Number(val));
                            }
                        }
                        else {
                            vals.push(val);
                        }
                    }
                    if (vals.length === 0) {
                        // do nothing (an undefined literal was stripped)
                    }
                    else if (vals.length === 1) {
                        const val = vals[0];
                        json.type = val === null ? &quot;null&quot; : typeof val;
                        json.const = val;
                    }
                    else {
                        if (vals.every((v) => typeof v === &quot;number&quot;))
                            json.type = &quot;number&quot;;
                        if (vals.every((v) => typeof v === &quot;string&quot;))
                            json.type = &quot;string&quot;;
                        if (vals.every((v) => typeof v === &quot;boolean&quot;))
                            json.type = &quot;string&quot;;
                        if (vals.every((v) => v === null))
                            json.type = &quot;null&quot;;
                        json.enum = vals;
                    }
                    break;
                }
                case &quot;file&quot;: {
                    const json = _json;
                    const file = {
                        type: &quot;string&quot;,
                        format: &quot;binary&quot;,
                        contentEncoding: &quot;binary&quot;,
                    };
                    const { minimum, maximum, mime } = schema._zod.bag;
                    if (minimum !== undefined)
                        file.minLength = minimum;
                    if (maximum !== undefined)
                        file.maxLength = maximum;
                    if (mime) {
                        if (mime.length === 1) {
                            file.contentMediaType = mime[0];
                            Object.assign(json, file);
                        }
                        else {
                            json.anyOf = mime.map((m) => {
                                const mFile = { ...file, contentMediaType: m };
                                return mFile;
                            });
                        }
                    }
                    else {
                        Object.assign(json, file);
                    }
                    // if (this.unrepresentable === &quot;throw&quot;) {
                    //   throw new Error(&quot;File cannot be represented in JSON Schema&quot;);
                    // }
                    break;
                }
                case &quot;transform&quot;: {
                    if (this.unrepresentable === &quot;throw&quot;) {
                        throw new Error(&quot;Transforms cannot be represented in JSON Schema&quot;);
                    }
                    break;
                }
                case &quot;nullable&quot;: {
                    const inner = this.process(def.innerType, params);
                    _json.anyOf = [inner, { type: &quot;null&quot; }];
                    break;
                }
                case &quot;nonoptional&quot;: {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    break;
                }
                case &quot;success&quot;: {
                    const json = _json;
                    json.type = &quot;boolean&quot;;
                    break;
                }
                case &quot;default&quot;: {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    _json.default = def.defaultValue;
                    break;
                }
                case &quot;prefault&quot;: {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    if (this.io === &quot;input&quot;)
                        _json._prefault = def.defaultValue;
                    break;
                }
                case &quot;catch&quot;: {
                    // use conditionals
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    let catchValue;
                    try {
                        catchValue = def.catchValue(undefined);
                    }
                    catch {
                        throw new Error(&quot;Dynamic catch values are not supported in JSON Schema&quot;);
                    }
                    _json.default = catchValue;
                    break;
                }
                case &quot;nan&quot;: {
                    if (this.unrepresentable === &quot;throw&quot;) {
                        throw new Error(&quot;NaN cannot be represented in JSON Schema&quot;);
                    }
                    break;
                }
                case &quot;template_literal&quot;: {
                    const json = _json;
                    const pattern = schema._zod.pattern;
                    if (!pattern)
                        throw new Error(&quot;Pattern not found in template literal&quot;);
                    json.type = &quot;string&quot;;
                    json.pattern = pattern.source;
                    break;
                }
                case &quot;pipe&quot;: {
                    const innerType = this.io === &quot;input&quot; ? (def.in._zod.def.type === &quot;transform&quot; ? def.out : def.in) : def.out;
                    this.process(innerType, params);
                    result.ref = innerType;
                    break;
                }
                case &quot;readonly&quot;: {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    _json.readOnly = true;
                    break;
                }
                // passthrough types
                case &quot;promise&quot;: {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    break;
                }
                case &quot;optional&quot;: {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    break;
                }
                case &quot;lazy&quot;: {
                    const innerType = schema._zod.innerType;
                    this.process(innerType, params);
                    result.ref = innerType;
                    break;
                }
                case &quot;custom&quot;: {
                    if (this.unrepresentable === &quot;throw&quot;) {
                        throw new Error(&quot;Custom types cannot be represented in JSON Schema&quot;);
                    }
                    break;
                }
                default: {
                    def;
                }
            }
        }
        // metadata
        const meta = this.metadataRegistry.get(schema);
        if (meta)
            Object.assign(result.schema, meta);
        if (this.io === &quot;input&quot; && isTransforming(schema)) {
            // examples/defaults only apply to output type of pipe
            delete result.schema.examples;
            delete result.schema.default;
        }
        // set prefault as default
        if (this.io === &quot;input&quot; && result.schema._prefault)
            (_a = result.schema).default ?? (_a.default = result.schema._prefault);
        delete result.schema._prefault;
        // pulling fresh from this.seen in case it was overwritten
        const _result = this.seen.get(schema);
        return _result.schema;
    }
    emit(schema, _params) {
        const params = {
            cycles: _params?.cycles ?? &quot;ref&quot;,
            reused: _params?.reused ?? &quot;inline&quot;,
            // unrepresentable: _params?.unrepresentable ?? &quot;throw&quot;,
            // uri: _params?.uri ?? ((id) => `${id}`),
            external: _params?.external ?? undefined,
        };
        // iterate over seen map;
        const root = this.seen.get(schema);
        if (!root)
            throw new Error(&quot;Unprocessed schema. This is a bug in Zod.&quot;);
        // initialize result with root schema fields
        // Object.assign(result, seen.cached);
        const makeURI = (entry) => {
            // comparing the seen objects because sometimes
            // multiple schemas map to the same seen object.
            // e.g. lazy
            // external is configured
            const defsSegment = this.target === &quot;draft-2020-12&quot; ? &quot;$defs&quot; : &quot;definitions&quot;;
            if (params.external) {
                const externalId = params.external.registry.get(entry[0])?.id; // ?? &quot;__shared&quot;;// `__schema${this.counter++}`;
                // check if schema is in the external registry
                if (externalId)
                    return { ref: params.external.uri(externalId) };
                // otherwise, add to __shared
                const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
                entry[1].defId = id;
                return { defId: id, ref: `${params.external.uri(&quot;__shared&quot;)}#/${defsSegment}/${id}` };
            }
            if (entry[1] === root) {
                return { ref: &quot;#&quot; };
            }
            // self-contained schema
            const uriPrefix = `#`;
            const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
            const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
            return { defId, ref: defUriPrefix + defId };
        };
        // stored cached version in `def` property
        // remove all properties, set $ref
        const extractToDef = (entry) => {
            if (entry[1].schema.$ref) {
                return;
            }
            const seen = entry[1];
            const { ref, defId } = makeURI(entry);
            seen.def = { ...seen.schema };
            // defId won&apos;t be set if the schema is a reference to an external schema
            if (defId)
                seen.defId = defId;
            // wipe away all properties except $ref
            const schema = seen.schema;
            for (const key in schema) {
                delete schema[key];
            }
            schema.$ref = ref;
        };
        // extract schemas into $defs
        for (const entry of this.seen.entries()) {
            const seen = entry[1];
            // convert root schema to # $ref
            // also prevents root schema from being extracted
            if (schema === entry[0]) {
                // do not copy to defs...this is the root schema
                extractToDef(entry);
                continue;
            }
            // extract schemas that are in the external registry
            if (params.external) {
                const ext = params.external.registry.get(entry[0])?.id;
                if (schema !== entry[0] && ext) {
                    extractToDef(entry);
                    continue;
                }
            }
            // extract schemas with `id` meta
            const id = this.metadataRegistry.get(entry[0])?.id;
            if (id) {
                extractToDef(entry);
                continue;
            }
            // break cycles
            if (seen.cycle) {
                if (params.cycles === &quot;throw&quot;) {
                    throw new Error(&quot;Cycle detected: &quot; +
                        `#/${seen.cycle?.join(&quot;/&quot;)}/<root>` +
                        '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
                }
                else if (params.cycles === "ref") {
                    extractToDef(entry);
                }
                continue;
            }
            // extract reused schemas
            if (seen.count > 1) {
                if (params.reused === "ref") {
                    extractToDef(entry);
                    // biome-ignore lint:
                    continue;
                }
            }
        }
        // flatten _refs
        const flattenRef = (zodSchema, params) => {
            const seen = this.seen.get(zodSchema);
            const schema = seen.def ?? seen.schema;
            const _cached = { ...schema };
            // already seen
            if (seen.ref === null) {
                return;
            }
            // flatten ref if defined
            const ref = seen.ref;
            seen.ref = null; // prevent recursion
            if (ref) {
                flattenRef(ref, params);
                // merge referenced schema into current
                const refSchema = this.seen.get(ref).schema;
                if (refSchema.$ref && params.target === "draft-7") {
                    schema.allOf = schema.allOf ?? [];
                    schema.allOf.push(refSchema);
                }
                else {
                    Object.assign(schema, refSchema);
                    Object.assign(schema, _cached); // prevent overwriting any fields in the original schema
                }
            }
            // execute overrides
            if (!seen.isParent)
                this.override({
                    zodSchema: zodSchema,
                    jsonSchema: schema,
                });
        };
        for (const entry of [...this.seen.entries()].reverse()) {
            flattenRef(entry[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
            result.$schema = "https://json-schema.org/draft/2020-12/schema";
        }
        else if (this.target === "draft-7") {
            result.$schema = "http://json-schema.org/draft-07/schema#";
        }
        else {
            console.warn(`Invalid target: ${this.target}`);
        }
        Object.assign(result, root.def);
        // build defs object
        const defs = params.external?.defs ?? {};
        for (const entry of this.seen.entries()) {
            const seen = entry[1];
            if (seen.def && seen.defId) {
                defs[seen.defId] = seen.def;
            }
        }
        // set definitions in result
        if (!params.external && Object.keys(defs).length > 0) {
            if (this.target === "draft-2020-12") {
                result.$defs = defs;
            }
            else {
                result.definitions = defs;
            }
        }
        try {
            // this "finalizes" this schema and ensures all cycles are removed
            // each call to .emit() is functionally independent
            // though the seen map is shared
            return JSON.parse(JSON.stringify(result));
        }
        catch (_err) {
            throw new Error("Error converting schema to JSON.");
        }
    }
}
export function toJSONSchema(input, _params) {
    if (input instanceof $ZodRegistry) {
        const gen = new JSONSchemaGenerator(_params);
        const defs = {};
        for (const entry of input._idmap.entries()) {
            const [_, schema] = entry;
            gen.process(schema);
        }
        const schemas = {};
        const external = {
            registry: input,
            uri: _params?.uri || ((id) => id),
            defs,
        };
        for (const entry of input._idmap.entries()) {
            const [key, schema] = entry;
            schemas[key] = gen.emit(schema, {
                ..._params,
                external,
            });
        }
        if (Object.keys(defs).length > 0) {
            const defsSegment = gen.target === "draft-2020-12" ? "$defs" : "definitions";
            schemas.__shared = {
                [defsSegment]: defs,
            };
        }
        return { schemas };
    }
    const gen = new JSONSchemaGenerator(_params);
    gen.process(input);
    return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
    const ctx = _ctx ?? { seen: new Set() };
    if (ctx.seen.has(_schema))
        return false;
    ctx.seen.add(_schema);
    const schema = _schema;
    const def = schema._zod.def;
    switch (def.type) {
        case "string":
        case "number":
        case "bigint":
        case "boolean":
        case "date":
        case "symbol":
        case "undefined":
        case "null":
        case "any":
        case "unknown":
        case "never":
        case "void":
        case "literal":
        case "enum":
        case "nan":
        case "file":
        case "template_literal":
            return false;
        case "array": {
            return isTransforming(def.element, ctx);
        }
        case "object": {
            for (const key in def.shape) {
                if (isTransforming(def.shape[key], ctx))
                    return true;
            }
            return false;
        }
        case "union": {
            for (const option of def.options) {
                if (isTransforming(option, ctx))
                    return true;
            }
            return false;
        }
        case "intersection": {
            return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
        }
        case "tuple": {
            for (const item of def.items) {
                if (isTransforming(item, ctx))
                    return true;
            }
            if (def.rest && isTransforming(def.rest, ctx))
                return true;
            return false;
        }
        case "record": {
            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "map": {
            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "set": {
            return isTransforming(def.valueType, ctx);
        }
        // inner types
        case "promise":
        case "optional":
        case "nonoptional":
        case "nullable":
        case "readonly":
            return isTransforming(def.innerType, ctx);
        case "lazy":
            return isTransforming(def.getter(), ctx);
        case "default": {
            return isTransforming(def.innerType, ctx);
        }
        case "prefault": {
            return isTransforming(def.innerType, ctx);
        }
        case "custom": {
            return false;
        }
        case "transform": {
            return true;
        }
        case "pipe": {
            return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
        }
        case "success": {
            return false;
        }
        case "catch": {
            return false;
        }
        default:
            def;
    }
    throw new Error(`Unknown schema type: ${def.type}`);
}
