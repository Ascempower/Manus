// functions
export function assertEqual(val) {
    return val;
}
export function assertNotEqual(val) {
    return val;
}
export function assertIs(_arg) { }
export function assertNever(_x) {
    throw new Error();
}
export function assert(_) { }
export function getEnumValues(entries) {
    const numericValues = Object.values(entries).filter((v) => typeof v === &quot;number&quot;);
    const values = Object.entries(entries)
        .filter(([k, _]) => numericValues.indexOf(+k) === -1)
        .map(([_, v]) => v);
    return values;
}
export function joinValues(array, separator = &quot;|&quot;) {
    return array.map((val) => stringifyPrimitive(val)).join(separator);
}
export function jsonStringifyReplacer(_, value) {
    if (typeof value === &quot;bigint&quot;)
        return value.toString();
    return value;
}
export function cached(getter) {
    const set = false;
    return {
        get value() {
            if (!set) {
                const value = getter();
                Object.defineProperty(this, &quot;value&quot;, { value });
                return value;
            }
            throw new Error(&quot;cached value already set&quot;);
        },
    };
}
export function nullish(input) {
    return input === null || input === undefined;
}
export function cleanRegex(source) {
    const start = source.startsWith(&quot;^&quot;) ? 1 : 0;
    const end = source.endsWith(&quot;$&quot;) ? source.length - 1 : source.length;
    return source.slice(start, end);
}
export function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(&quot;.&quot;)[1] || &quot;&quot;).length;
    const stepDecCount = (step.toString().split(&quot;.&quot;)[1] || &quot;&quot;).length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(&quot;.&quot;, &quot;&quot;));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(&quot;.&quot;, &quot;&quot;));
    return (valInt % stepInt) / 10 ** decCount;
}
export function defineLazy(object, key, getter) {
    const set = false;
    Object.defineProperty(object, key, {
        get() {
            if (!set) {
                const value = getter();
                object[key] = value;
                return value;
            }
            throw new Error(&quot;cached value already set&quot;);
        },
        set(v) {
            Object.defineProperty(object, key, {
                value: v,
                // configurable: true,
            });
            // object[key] = v;
        },
        configurable: true,
    });
}
export function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
        value,
        writable: true,
        enumerable: true,
        configurable: true,
    });
}
export function getElementAtPath(obj, path) {
    if (!path)
        return obj;
    return path.reduce((acc, key) => acc?.[key], obj);
}
export function promiseAllObject(promisesObj) {
    const keys = Object.keys(promisesObj);
    const promises = keys.map((key) => promisesObj[key]);
    return Promise.all(promises).then((results) => {
        const resolvedObj = {};
        for (let i = 0; i < keys.length; i++) {
            resolvedObj[keys[i]] = results[i];
        }
        return resolvedObj;
    });
}
export function randomString(length = 10) {
    const chars = "abcdefghijklmnopqrstuvwxyz";
    let str = "";
    for (let i = 0; i < length; i++) {
        str += chars[Math.floor(Math.random() * chars.length)];
    }
    return str;
}
export function esc(str) {
    return JSON.stringify(str);
}
export function isObject(data) {
    return typeof data === "object" && data !== null && !Array.isArray(data);
}
export const allowsEval = cached(() => {
    try {
        const F = Function;
        new F(&quot;&quot;);
        return true;
    }
    catch (_) {
        return false;
    }
});
function _isObject(o) {
    return Object.prototype.toString.call(o) === &quot;[object Object]&quot;;
}
export function isPlainObject(o) {
    if (isObject(o) === false)
        return false;
    // modified constructor
    const ctor = o.constructor;
    if (ctor === undefined)
        return true;
    // modified prototype
    const prot = ctor.prototype;
    if (isObject(prot) === false)
        return false;
    // ctor doesn&apos;t have static `isPrototypeOf`
    if (Object.prototype.hasOwnProperty.call(prot, &quot;isPrototypeOf&quot;) === false) {
        return false;
    }
    return true;
}
export function numKeys(data) {
    let keyCount = 0;
    for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
            keyCount++;
        }
    }
    return keyCount;
}
export const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case &quot;undefined&quot;:
            return &quot;undefined&quot;;
        case &quot;string&quot;:
            return &quot;string&quot;;
        case &quot;number&quot;:
            return Number.isNaN(data) ? &quot;nan&quot; : &quot;number&quot;;
        case &quot;boolean&quot;:
            return &quot;boolean&quot;;
        case &quot;function&quot;:
            return &quot;function&quot;;
        case &quot;bigint&quot;:
            return &quot;bigint&quot;;
        case &quot;symbol&quot;:
            return &quot;symbol&quot;;
        case &quot;object&quot;:
            if (Array.isArray(data)) {
                return &quot;array&quot;;
            }
            if (data === null) {
                return &quot;null&quot;;
            }
            if (data.then && typeof data.then === &quot;function&quot; && data.catch && typeof data.catch === &quot;function&quot;) {
                return &quot;promise&quot;;
            }
            if (typeof Map !== &quot;undefined&quot; && data instanceof Map) {
                return &quot;map&quot;;
            }
            if (typeof Set !== &quot;undefined&quot; && data instanceof Set) {
                return &quot;set&quot;;
            }
            if (typeof Date !== &quot;undefined&quot; && data instanceof Date) {
                return &quot;date&quot;;
            }
            if (typeof File !== &quot;undefined&quot; && data instanceof File) {
                return &quot;file&quot;;
            }
            return &quot;object&quot;;
        default:
            throw new Error(`Unknown data type: ${t}`);
    }
};
export const propertyKeyTypes = new Set([&quot;string&quot;, &quot;number&quot;, &quot;symbol&quot;]);
export const primitiveTypes = new Set([&quot;string&quot;, &quot;number&quot;, &quot;bigint&quot;, &quot;boolean&quot;, &quot;symbol&quot;, &quot;undefined&quot;]);
export function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, &quot;\\$&&quot;);
}
// zod-specific utils
export function clone(inst, def, params) {
    const cl = new inst._zod.constr(def ?? inst._zod.def);
    if (!def || params?.parent)
        cl._zod.parent = inst;
    return cl;
}
export function normalizeParams(_params) {
    const params = _params;
    if (!params)
        return {};
    if (typeof params === &quot;string&quot;)
        return { error: () => params };
    if (params?.message !== undefined) {
        if (params?.error !== undefined)
            throw new Error(&quot;Cannot specify both `message` and `error` params&quot;);
        params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === &quot;string&quot;)
        return { ...params, error: () => params.error };
    return params;
}
export function createTransparentProxy(getter) {
    let target;
    return new Proxy({}, {
        get(_, prop, receiver) {
            target ?? (target = getter());
            return Reflect.get(target, prop, receiver);
        },
        set(_, prop, value, receiver) {
            target ?? (target = getter());
            return Reflect.set(target, prop, value, receiver);
        },
        has(_, prop) {
            target ?? (target = getter());
            return Reflect.has(target, prop);
        },
        deleteProperty(_, prop) {
            target ?? (target = getter());
            return Reflect.deleteProperty(target, prop);
        },
        ownKeys(_) {
            target ?? (target = getter());
            return Reflect.ownKeys(target);
        },
        getOwnPropertyDescriptor(_, prop) {
            target ?? (target = getter());
            return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        defineProperty(_, prop, descriptor) {
            target ?? (target = getter());
            return Reflect.defineProperty(target, prop, descriptor);
        },
    });
}
export function stringifyPrimitive(value) {
    if (typeof value === &quot;bigint&quot;)
        return value.toString() + &quot;n&quot;;
    if (typeof value === &quot;string&quot;)
        return `&quot;${value}&quot;`;
    return `${value}`;
}
export function optionalKeys(shape) {
    return Object.keys(shape).filter((k) => {
        return shape[k]._zod.optin === &quot;optional&quot; && shape[k]._zod.optout === &quot;optional&quot;;
    });
}
export const NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-3.4028234663852886e38, 3.4028234663852886e38],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
};
export const BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__*/ BigInt(&quot;-9223372036854775808&quot;), /* @__PURE__*/ BigInt(&quot;9223372036854775807&quot;)],
    uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt(&quot;18446744073709551615&quot;)],
};
export function pick(schema, mask) {
    const newShape = {};
    const currDef = schema._zod.def; //.shape;
    for (const key in mask) {
        if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: &quot;${key}&quot;`);
        }
        if (!mask[key])
            continue;
        // pick key
        newShape[key] = currDef.shape[key];
    }
    return clone(schema, {
        ...schema._zod.def,
        shape: newShape,
        checks: [],
    });
}
export function omit(schema, mask) {
    const newShape = { ...schema._zod.def.shape };
    const currDef = schema._zod.def; //.shape;
    for (const key in mask) {
        if (!(key in currDef.shape)) {
            throw new Error(`Unrecognized key: &quot;${key}&quot;`);
        }
        if (!mask[key])
            continue;
        delete newShape[key];
    }
    return clone(schema, {
        ...schema._zod.def,
        shape: newShape,
        checks: [],
    });
}
export function extend(schema, shape) {
    const def = {
        ...schema._zod.def,
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, &quot;shape&quot;, _shape); // self-caching
            return _shape;
        },
        checks: [], // delete existing checks
    };
    return clone(schema, def);
}
export function merge(a, b) {
    return clone(a, {
        ...a._zod.def,
        get shape() {
            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
            assignProp(this, &quot;shape&quot;, _shape); // self-caching
            return _shape;
        },
        catchall: b._zod.def.catchall,
        checks: [], // delete existing checks
    });
}
export function partial(Class, schema, mask) {
    const oldShape = schema._zod.def.shape;
    const shape = { ...oldShape };
    if (mask) {
        for (const key in mask) {
            if (!(key in oldShape)) {
                throw new Error(`Unrecognized key: &quot;${key}&quot;`);
            }
            if (!mask[key])
                continue;
            shape[key] = Class
                ? new Class({
                    type: &quot;optional&quot;,
                    innerType: oldShape[key],
                })
                : oldShape[key];
        }
    }
    else {
        for (const key in oldShape) {
            shape[key] = Class
                ? new Class({
                    type: &quot;optional&quot;,
                    innerType: oldShape[key],
                })
                : oldShape[key];
        }
    }
    return clone(schema, {
        ...schema._zod.def,
        shape,
        checks: [],
    });
}
export function required(Class, schema, mask) {
    const oldShape = schema._zod.def.shape;
    const shape = { ...oldShape };
    if (mask) {
        for (const key in mask) {
            if (!(key in shape)) {
                throw new Error(`Unrecognized key: &quot;${key}&quot;`);
            }
            if (!mask[key])
                continue;
            // overwrite with non-optional
            shape[key] = new Class({
                type: &quot;nonoptional&quot;,
                innerType: oldShape[key],
            });
        }
    }
    else {
        for (const key in oldShape) {
            // overwrite with non-optional
            shape[key] = new Class({
                type: &quot;nonoptional&quot;,
                innerType: oldShape[key],
            });
        }
    }
    return clone(schema, {
        ...schema._zod.def,
        shape,
        // optional: [],
        checks: [],
    });
}
export function aborted(x, startIndex = 0) {
    for (let i = startIndex; i < x.issues.length; i++) {
        if (x.issues[i].continue !== true)
            return true;
    }
    return false;
}
export function prefixIssues(path, issues) {
    return issues.map((iss) => {
        var _a;
        (_a = iss).path ?? (_a.path = []);
        iss.path.unshift(path);
        return iss;
    });
}
export function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
}
export function finalizeIssue(iss, ctx, config) {
    const full = { ...iss, path: iss.path ?? [] };
    // for backwards compatibility
    if (!iss.message) {
        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
            unwrapMessage(ctx?.error?.(iss)) ??
            unwrapMessage(config.customError?.(iss)) ??
            unwrapMessage(config.localeError?.(iss)) ??
            "Invalid input";
        full.message = message;
    }
    // delete (full as any).def;
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
        delete full.input;
    }
    return full;
}
export function getSizableOrigin(input) {
    if (input instanceof Set)
        return "set";
    if (input instanceof Map)
        return "map";
    if (input instanceof File)
        return "file";
    return "unknown";
}
export function getLengthableOrigin(input) {
    if (Array.isArray(input))
        return "array";
    if (typeof input === "string")
        return "string";
    return "unknown";
}
export function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
        return {
            message: iss,
            code: "custom",
            input,
            inst,
        };
    }
    return { ...iss };
}
export function cleanEnum(obj) {
    return Object.entries(obj)
        .filter(([k, _]) => {
        // return true if NaN, meaning it's not a number, thus a string key
        return Number.isNaN(Number.parseInt(k, 10));
    })
        .map((el) => el[1]);
}
// instanceof
export class Class {
    constructor(..._args) { }
}
