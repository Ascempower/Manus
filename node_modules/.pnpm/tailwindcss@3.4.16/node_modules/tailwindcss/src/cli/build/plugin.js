// @ts-check

import path from 'path'
import fs from 'fs'
import postcssrc from 'postcss-load-config'
import { lilconfig } from 'lilconfig'
import loadPlugins from 'postcss-load-config/src/plugins' // Little bit scary, looking at private/internal API
import loadOptions from 'postcss-load-config/src/options' // Little bit scary, looking at private/internal API

import tailwind from '../../processTailwindFeatures'
import { loadAutoprefixer, loadCssNano, loadPostcss, loadPostcssImport } from './deps'
import { formatNodes, drainStdin, outputFile } from './utils'
import { env } from '../../lib/sharedState'
import resolveConfig from '../../../resolveConfig.js'
import { createBroadPatternCheck, parseCandidateFiles } from '../../lib/content.js'
import { createWatcher } from './watching.js'
import fastGlob from 'fast-glob'
import { findAtConfigPath } from '../../lib/findAtConfigPath.js'
import log from '../../util/log'
import { loadConfig } from '../../lib/load-config'
import getModuleDependencies from '../../lib/getModuleDependencies'

/**
 *
 * @param {string} [customPostCssPath ]
 * @returns
 */
async function loadPostCssPlugins(customPostCssPath) {
  let config = customPostCssPath
    ? await (async () => {
        let file = path.resolve(customPostCssPath)

        // Implementation, see: https://unpkg.com/browse/postcss-load-config@3.1.0/src/index.js
        // @ts-ignore
        let { config = {} } = await lilconfig(&apos;postcss&apos;).load(file)
        if (typeof config === &apos;function&apos;) {
          config = config()
        } else {
          config = Object.assign({}, config)
        }

        if (!config.plugins) {
          config.plugins = []
        }

        return {
          file,
          plugins: loadPlugins(config, file),
          options: loadOptions(config, file),
        }
      })()
    : await postcssrc()

  let configPlugins = config.plugins

  let configPluginTailwindIdx = configPlugins.findIndex((plugin) => {
    if (typeof plugin === &apos;function&apos; && plugin.name === &apos;tailwindcss&apos;) {
      return true
    }

    if (typeof plugin === &apos;object&apos; && plugin !== null && plugin.postcssPlugin === &apos;tailwindcss&apos;) {
      return true
    }

    return false
  })

  let beforePlugins =
    configPluginTailwindIdx === -1 ? [] : configPlugins.slice(0, configPluginTailwindIdx)
  let afterPlugins =
    configPluginTailwindIdx === -1
      ? configPlugins
      : configPlugins.slice(configPluginTailwindIdx + 1)

  return [beforePlugins, afterPlugins, config.options]
}

function loadBuiltinPostcssPlugins() {
  let postcss = loadPostcss()
  let IMPORT_COMMENT = &apos;__TAILWIND_RESTORE_IMPORT__: &apos;
  return [
    [
      (root) => {
        root.walkAtRules(&apos;import&apos;, (rule) => {
          if (rule.params.slice(1).startsWith(&apos;tailwindcss/&apos;)) {
            rule.after(postcss.comment({ text: IMPORT_COMMENT + rule.params }))
            rule.remove()
          }
        })
      },
      loadPostcssImport(),
      (root) => {
        root.walkComments((rule) => {
          if (rule.text.startsWith(IMPORT_COMMENT)) {
            rule.after(
              postcss.atRule({
                name: &apos;import&apos;,
                params: rule.text.replace(IMPORT_COMMENT, &apos;&apos;),
              })
            )
            rule.remove()
          }
        })
      },
    ],
    [],
    {},
  ]
}

let state = {
  /** @type {any} */
  context: null,

  /** @type {ReturnType<typeof createWatcher> | null} */
  watcher: null,

  /** @type {{content: string, extension: string}[]} */
  changedContent: [],

  /** @type {ReturnType<typeof load> | null} */
  configBag: null,

  contextDependencies: new Set(),

  /** @type {import(&apos;../../lib/content.js&apos;).ContentPath[]} */
  contentPaths: [],

  refreshContentPaths() {
    this.contentPaths = parseCandidateFiles(this.context, this.context?.tailwindConfig)
  },

  get config() {
    return this.context.tailwindConfig
  },

  get contentPatterns() {
    return {
      all: this.contentPaths.map((contentPath) => contentPath.pattern),
      dynamic: this.contentPaths
        .filter((contentPath) => contentPath.glob !== undefined)
        .map((contentPath) => contentPath.pattern),
    }
  },

  loadConfig(configPath, content) {
    if (this.watcher && configPath) {
      this.refreshConfigDependencies()
    }

    let config = loadConfig(configPath)
    let dependencies = getModuleDependencies(configPath)
    this.configBag = {
      config,
      dependencies,
      dispose() {
        for (let file of dependencies) {
          delete require.cache[require.resolve(file)]
        }
      },
    }

    // @ts-ignore
    this.configBag.config = resolveConfig(this.configBag.config, { content: { files: [] } })

    // Override content files if `--content` has been passed explicitly
    if (content?.length > 0) {
      this.configBag.config.content.files = content
    }

    return this.configBag.config
  },

  refreshConfigDependencies() {
    env.DEBUG && console.time(&apos;Module dependencies&apos;)
    this.configBag?.dispose()
    env.DEBUG && console.timeEnd(&apos;Module dependencies&apos;)
  },

  readContentPaths() {
    let content = []

    // Resolve globs from the content config
    // TODO: When we make the postcss plugin async-capable this can become async
    let files = fastGlob.sync(this.contentPatterns.all)

    let checkBroadPattern = createBroadPatternCheck(this.contentPatterns.all)

    for (let file of files) {
      checkBroadPattern(file)

      content.push({
        content: fs.readFileSync(path.resolve(file), &apos;utf8&apos;),
        extension: path.extname(file).slice(1),
      })
    }

    // Resolve raw content in the tailwind config
    let rawContent = this.config.content.files.filter((file) => {
      return file !== null && typeof file === &apos;object&apos;
    })

    for (let { raw: htmlContent, extension = &apos;html&apos; } of rawContent) {
      content.push({ content: htmlContent, extension })
    }

    return content
  },

  getContext({ createContext, cliConfigPath, root, result, content }) {
    env.DEBUG && console.time(&apos;Searching for config&apos;)
    let configPath = findAtConfigPath(root, result) ?? cliConfigPath
    env.DEBUG && console.timeEnd(&apos;Searching for config&apos;)

    if (this.context) {
      this.context.changedContent = this.changedContent.splice(0)

      return this.context
    }

    env.DEBUG && console.time(&apos;Loading config&apos;)
    let config = this.loadConfig(configPath, content)
    env.DEBUG && console.timeEnd(&apos;Loading config&apos;)

    env.DEBUG && console.time(&apos;Creating context&apos;)
    this.context = createContext(config, [])
    Object.assign(this.context, {
      userConfigPath: configPath,
    })
    env.DEBUG && console.timeEnd(&apos;Creating context&apos;)

    env.DEBUG && console.time(&apos;Resolving content paths&apos;)
    this.refreshContentPaths()
    env.DEBUG && console.timeEnd(&apos;Resolving content paths&apos;)

    if (this.watcher) {
      env.DEBUG && console.time(&apos;Watch new files&apos;)
      this.watcher.refreshWatchedFiles()
      env.DEBUG && console.timeEnd(&apos;Watch new files&apos;)
    }

    for (let file of this.readContentPaths()) {
      this.context.changedContent.push(file)
    }

    return this.context
  },
}

export async function createProcessor(args, cliConfigPath) {
  let postcss = loadPostcss()

  let input = args[&apos;--input&apos;]
  let output = args[&apos;--output&apos;]
  let includePostCss = args[&apos;--postcss&apos;]
  let customPostCssPath = typeof args[&apos;--postcss&apos;] === &apos;string&apos; ? args[&apos;--postcss&apos;] : undefined

  let [beforePlugins, afterPlugins, postcssOptions] = includePostCss
    ? await loadPostCssPlugins(customPostCssPath)
    : loadBuiltinPostcssPlugins()

  if (args[&apos;--purge&apos;]) {
    log.warn(&apos;purge-flag-deprecated&apos;, [
      &apos;The `--purge` flag has been deprecated.&apos;,
      &apos;Please use `--content` instead.&apos;,
    ])

    if (!args[&apos;--content&apos;]) {
      args[&apos;--content&apos;] = args[&apos;--purge&apos;]
    }
  }

  let content = args[&apos;--content&apos;]?.split(/(?<!{[^}]+),/) ?? []

  let tailwindPlugin = () => {
    return {
      postcssPlugin: &apos;tailwindcss&apos;,
      async Once(root, { result }) {
        env.DEBUG && console.time(&apos;Compiling CSS&apos;)
        await tailwind(({ createContext }) => {
          console.error()
          console.error(&apos;Rebuilding...&apos;)

          return () => {
            return state.getContext({
              createContext,
              cliConfigPath,
              root,
              result,
              content,
            })
          }
        })(root, result)
        env.DEBUG && console.timeEnd(&apos;Compiling CSS&apos;)
      },
    }
  }

  tailwindPlugin.postcss = true

  let plugins = [
    ...beforePlugins,
    tailwindPlugin,
    !args[&apos;--minify&apos;] && formatNodes,
    ...afterPlugins,
    !args[&apos;--no-autoprefixer&apos;] && loadAutoprefixer(),
    args[&apos;--minify&apos;] && loadCssNano(),
  ].filter(Boolean)

  /** @type {import(&apos;postcss&apos;).Processor} */
  // @ts-ignore
  let processor = postcss(plugins)

  async function readInput() {
    // Piping in data, let&apos;s drain the stdin
    if (input === &apos;-&apos;) {
      return drainStdin()
    }

    // Input file has been provided
    if (input) {
      return fs.promises.readFile(path.resolve(input), &apos;utf8&apos;)
    }

    // No input file provided, fallback to default at-rules
    return &apos;@tailwind base; @tailwind components; @tailwind utilities&apos;
  }

  async function build() {
    let start = process.hrtime.bigint()

    return readInput()
      .then((css) => processor.process(css, { ...postcssOptions, from: input, to: output }))
      .then((result) => {
        if (!state.watcher) {
          return result
        }

        env.DEBUG && console.time(&apos;Recording PostCSS dependencies&apos;)
        for (let message of result.messages) {
          if (message.type === &apos;dependency&apos;) {
            state.contextDependencies.add(message.file)
          }
        }
        env.DEBUG && console.timeEnd(&apos;Recording PostCSS dependencies&apos;)

        // TODO: This needs to be in a different spot
        env.DEBUG && console.time(&apos;Watch new files&apos;)
        state.watcher.refreshWatchedFiles()
        env.DEBUG && console.timeEnd(&apos;Watch new files&apos;)

        return result
      })
      .then((result) => {
        if (!output) {
          process.stdout.write(result.css)
          return
        }

        return Promise.all([
          outputFile(result.opts.to, result.css),
          result.map && outputFile(result.opts.to + &apos;.map&apos;, result.map.toString()),
        ])
      })
      .then(() => {
        let end = process.hrtime.bigint()
        console.error()
        console.error(&apos;Done in&apos;, (end - start) / BigInt(1e6) + &apos;ms.&apos;)
      })
      .then(
        () => {},
        (err) => {
          // TODO: If an initial build fails we can&apos;t easily pick up any PostCSS dependencies
          // that were collected before the error occurred
          // The result is not stored on the error so we have to store it externally
          // and pull the messages off of it here somehow

          // This results in a less than ideal DX because the watcher will not pick up
          // changes to imported CSS if one of them caused an error during the initial build
          // If you fix it and then save the main CSS file so there&apos;s no error
          // The watcher will start watching the imported CSS files and will be
          // resilient to future errors.

          if (state.watcher) {
            console.error(err)
          } else {
            return Promise.reject(err)
          }
        }
      )
  }

  /**
   * @param {{file: string, content(): Promise<string>, extension: string}[]} changes
   */
  async function parseChanges(changes) {
    return Promise.all(
      changes.map(async (change) => ({
        content: await change.content(),
        extension: change.extension,
      }))
    )
  }

  if (input !== undefined && input !== &apos;-&apos;) {
    state.contextDependencies.add(path.resolve(input))
  }

  return {
    build,
    watch: async () => {
      state.watcher = createWatcher(args, {
        state,

        /**
         * @param {{file: string, content(): Promise<string>, extension: string}[]} changes
         */
        async rebuild(changes) {
          let needsNewContext = changes.some((change) => {
            return (
              state.configBag?.dependencies.has(change.file) ||
              state.contextDependencies.has(change.file)
            )
          })

          if (needsNewContext) {
            state.context = null
          } else {
            for (let change of await parseChanges(changes)) {
              state.changedContent.push(change)
            }
          }

          return build()
        },
      })

      await build()
    },
  }
}
