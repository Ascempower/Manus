/**
 * @fileoverview Main API Class
 * @author Kai Cataldo
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const path = require("node:path");
const fs = require("node:fs");
const { promisify } = require("node:util");
const {
	CLIEngine,
	getCLIEngineInternalSlots,
} = require("../cli-engine/cli-engine");
const BuiltinRules = require("../rules");
const {
	Legacy: {
		ConfigOps: { getRuleSeverity },
	},
} = require("@eslint/eslintrc");
const { version } = require("../../package.json");

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/** @typedef {import("../cli-engine/cli-engine").LintReport} CLIEngineLintReport */
/** @typedef {import("../types").ESLint.ConfigData} ConfigData */
/** @typedef {import("../types").ESLint.DeprecatedRuleUse} DeprecatedRuleInfo */
/** @typedef {import("../types").Linter.LintMessage} LintMessage */
/** @typedef {import("../types").ESLint.LintResult} LintResult */
/** @typedef {import("../types").ESLint.Plugin} Plugin */
/** @typedef {import("../types").ESLint.ResultsMeta} ResultsMeta */
/** @typedef {import("../types").Rule.RuleModule} Rule */
/** @typedef {import("../types").Linter.SuppressedLintMessage} SuppressedLintMessage */

/**
 * The main formatter object.
 * @typedef LoadedFormatter
 * @property {(results: LintResult[], resultsMeta: ResultsMeta) => string | Promise<string>} format format function.
 */

/**
 * The options with which to configure the LegacyESLint instance.
 * @typedef {Object} LegacyESLintOptions
 * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.
 * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance
 * @property {boolean} [cache] Enable result caching.
 * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.
 * @property {&quot;metadata&quot; | &quot;content&quot;} [cacheStrategy] The strategy used to detect changed files.
 * @property {string} [cwd] The value to use for the current working directory.
 * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn&apos;t throw even if no target files found. Defaults to `true`.
 * @property {string[]} [extensions] An array of file extensions to check.
 * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.
 * @property {string[]} [fixTypes] Array of rule types to apply fixes for.
 * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property {boolean} [ignore] False disables use of .eslintignore.
 * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.
 * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance
 * @property {string} [overrideConfigFile] The configuration file to use.
 * @property {Record<string,Plugin>|null} [plugins] Preloaded plugins. This is a map-like object, keys are plugin IDs and each value is implementation.
 * @property {&quot;error&quot; | &quot;warn&quot; | &quot;off&quot;} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.
 * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD.
 * @property {string[]} [rulePaths] An array of directories to load custom rules from.
 * @property {boolean} [useEslintrc] False disables looking for .eslintrc.* files.
 * @property {boolean} [passOnNoPatterns=false] When set to true, missing patterns cause
 *      the linting operation to short circuit and not report any failures.
 */

/**
 * A rules metadata object.
 * @typedef {Object} RulesMeta
 * @property {string} id The plugin ID.
 * @property {Object} definition The plugin definition.
 */

/**
 * Private members for the `ESLint` instance.
 * @typedef {Object} ESLintPrivateMembers
 * @property {CLIEngine} cliEngine The wrapped CLIEngine instance.
 * @property {LegacyESLintOptions} options The options used to instantiate the ESLint instance.
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const writeFile = promisify(fs.writeFile);

/**
 * The map with which to store private class members.
 * @type {WeakMap<ESLint, ESLintPrivateMembers>}
 */
const privateMembersMap = new WeakMap();

/**
 * Check if a given value is a non-empty string or not.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is a non-empty string.
 */
function isNonEmptyString(value) {
	return typeof value === &quot;string&quot; && value.trim() !== &quot;&quot;;
}

/**
 * Check if a given value is an array of non-empty strings or not.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is an array of non-empty strings.
 */
function isArrayOfNonEmptyString(value) {
	return (
		Array.isArray(value) && value.length && value.every(isNonEmptyString)
	);
}

/**
 * Check if a given value is an empty array or an array of non-empty strings.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is an empty array or an array of non-empty
 *      strings.
 */
function isEmptyArrayOrArrayOfNonEmptyString(value) {
	return Array.isArray(value) && value.every(isNonEmptyString);
}

/**
 * Check if a given value is a valid fix type or not.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is valid fix type.
 */
function isFixType(value) {
	return (
		value === &quot;directive&quot; ||
		value === &quot;problem&quot; ||
		value === &quot;suggestion&quot; ||
		value === &quot;layout&quot;
	);
}

/**
 * Check if a given value is an array of fix types or not.
 * @param {any} value The value to check.
 * @returns {boolean} `true` if `value` is an array of fix types.
 */
function isFixTypeArray(value) {
	return Array.isArray(value) && value.every(isFixType);
}

/**
 * The error for invalid options.
 */
class ESLintInvalidOptionsError extends Error {
	constructor(messages) {
		super(`Invalid Options:\n- ${messages.join(&quot;\n- &quot;)}`);
		this.code = &quot;ESLINT_INVALID_OPTIONS&quot;;
		Error.captureStackTrace(this, ESLintInvalidOptionsError);
	}
}

/**
 * Validates and normalizes options for the wrapped CLIEngine instance.
 * @param {LegacyESLintOptions} options The options to process.
 * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.
 * @returns {LegacyESLintOptions} The normalized options.
 */
function processOptions({
	allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.
	baseConfig = null,
	cache = false,
	cacheLocation = &quot;.eslintcache&quot;,
	cacheStrategy = &quot;metadata&quot;,
	cwd = process.cwd(),
	errorOnUnmatchedPattern = true,
	extensions = null, // ← should be null by default because if it&apos;s an array then it suppresses RFC20 feature.
	fix = false,
	fixTypes = null, // ← should be null by default because if it&apos;s an array then it suppresses rules that don&apos;t have the `meta.type` property.
	flags /* eslint-disable-line no-unused-vars -- leaving for compatibility with ESLint#hasFlag */,
	globInputPaths = true,
	ignore = true,
	ignorePath = null, // ← should be null by default because if it&apos;s a string then it may throw ENOENT.
	overrideConfig = null,
	overrideConfigFile = null,
	plugins = {},
	reportUnusedDisableDirectives = null, // ← should be null by default because if it&apos;s a string then it overrides the &apos;reportUnusedDisableDirectives&apos; setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.
	resolvePluginsRelativeTo = null, // ← should be null by default because if it&apos;s a string then it suppresses RFC47 feature.
	rulePaths = [],
	useEslintrc = true,
	passOnNoPatterns = false,
	...unknownOptions
}) {
	const errors = [];
	const unknownOptionKeys = Object.keys(unknownOptions);

	if (unknownOptionKeys.length >= 1) {
		errors.push(`Unknown options: ${unknownOptionKeys.join(&quot;, &quot;)}`);
		if (unknownOptionKeys.includes(&quot;cacheFile&quot;)) {
			errors.push(
				&quot;&apos;cacheFile&apos; has been removed. Please use the &apos;cacheLocation&apos; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;configFile&quot;)) {
			errors.push(
				&quot;&apos;configFile&apos; has been removed. Please use the &apos;overrideConfigFile&apos; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;envs&quot;)) {
			errors.push(
				&quot;&apos;envs&apos; has been removed. Please use the &apos;overrideConfig.env&apos; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;globals&quot;)) {
			errors.push(
				&quot;&apos;globals&apos; has been removed. Please use the &apos;overrideConfig.globals&apos; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;ignorePattern&quot;)) {
			errors.push(
				&quot;&apos;ignorePattern&apos; has been removed. Please use the &apos;overrideConfig.ignorePatterns&apos; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;parser&quot;)) {
			errors.push(
				&quot;&apos;parser&apos; has been removed. Please use the &apos;overrideConfig.parser&apos; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;parserOptions&quot;)) {
			errors.push(
				&quot;&apos;parserOptions&apos; has been removed. Please use the &apos;overrideConfig.parserOptions&apos; option instead.&quot;,
			);
		}
		if (unknownOptionKeys.includes(&quot;rules&quot;)) {
			errors.push(
				&quot;&apos;rules&apos; has been removed. Please use the &apos;overrideConfig.rules&apos; option instead.&quot;,
			);
		}
	}
	if (typeof allowInlineConfig !== &quot;boolean&quot;) {
		errors.push(&quot;&apos;allowInlineConfig&apos; must be a boolean.&quot;);
	}
	if (typeof baseConfig !== &quot;object&quot;) {
		errors.push(&quot;&apos;baseConfig&apos; must be an object or null.&quot;);
	}
	if (typeof cache !== &quot;boolean&quot;) {
		errors.push(&quot;&apos;cache&apos; must be a boolean.&quot;);
	}
	if (!isNonEmptyString(cacheLocation)) {
		errors.push(&quot;&apos;cacheLocation&apos; must be a non-empty string.&quot;);
	}
	if (cacheStrategy !== &quot;metadata&quot; && cacheStrategy !== &quot;content&quot;) {
		errors.push(&apos;\&apos;cacheStrategy\&apos; must be any of &quot;metadata&quot;, &quot;content&quot;.&apos;);
	}
	if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {
		errors.push(&quot;&apos;cwd&apos; must be an absolute path.&quot;);
	}
	if (typeof errorOnUnmatchedPattern !== &quot;boolean&quot;) {
		errors.push(&quot;&apos;errorOnUnmatchedPattern&apos; must be a boolean.&quot;);
	}
	if (
		!isEmptyArrayOrArrayOfNonEmptyString(extensions) &&
		extensions !== null
	) {
		errors.push(
			&quot;&apos;extensions&apos; must be an array of non-empty strings or null.&quot;,
		);
	}
	if (typeof fix !== &quot;boolean&quot; && typeof fix !== &quot;function&quot;) {
		errors.push(&quot;&apos;fix&apos; must be a boolean or a function.&quot;);
	}
	if (fixTypes !== null && !isFixTypeArray(fixTypes)) {
		errors.push(
			&apos;\&apos;fixTypes\&apos; must be an array of any of &quot;directive&quot;, &quot;problem&quot;, &quot;suggestion&quot;, and &quot;layout&quot;.&apos;,
		);
	}
	if (typeof globInputPaths !== &quot;boolean&quot;) {
		errors.push(&quot;&apos;globInputPaths&apos; must be a boolean.&quot;);
	}
	if (typeof ignore !== &quot;boolean&quot;) {
		errors.push(&quot;&apos;ignore&apos; must be a boolean.&quot;);
	}
	if (!isNonEmptyString(ignorePath) && ignorePath !== null) {
		errors.push(&quot;&apos;ignorePath&apos; must be a non-empty string or null.&quot;);
	}
	if (typeof overrideConfig !== &quot;object&quot;) {
		errors.push(&quot;&apos;overrideConfig&apos; must be an object or null.&quot;);
	}
	if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null) {
		errors.push(&quot;&apos;overrideConfigFile&apos; must be a non-empty string or null.&quot;);
	}
	if (typeof plugins !== &quot;object&quot;) {
		errors.push(&quot;&apos;plugins&apos; must be an object or null.&quot;);
	} else if (plugins !== null && Object.keys(plugins).includes(&quot;&quot;)) {
		errors.push(&quot;&apos;plugins&apos; must not include an empty string.&quot;);
	}
	if (Array.isArray(plugins)) {
		errors.push(
			&quot;&apos;plugins&apos; doesn&apos;t add plugins to configuration to load. Please use the &apos;overrideConfig.plugins&apos; option instead.&quot;,
		);
	}
	if (
		reportUnusedDisableDirectives !== &quot;error&quot; &&
		reportUnusedDisableDirectives !== &quot;warn&quot; &&
		reportUnusedDisableDirectives !== &quot;off&quot; &&
		reportUnusedDisableDirectives !== null
	) {
		errors.push(
			&apos;\&apos;reportUnusedDisableDirectives\&apos; must be any of &quot;error&quot;, &quot;warn&quot;, &quot;off&quot;, and null.&apos;,
		);
	}
	if (
		!isNonEmptyString(resolvePluginsRelativeTo) &&
		resolvePluginsRelativeTo !== null
	) {
		errors.push(
			&quot;&apos;resolvePluginsRelativeTo&apos; must be a non-empty string or null.&quot;,
		);
	}
	if (!isEmptyArrayOrArrayOfNonEmptyString(rulePaths)) {
		errors.push(&quot;&apos;rulePaths&apos; must be an array of non-empty strings.&quot;);
	}
	if (typeof useEslintrc !== &quot;boolean&quot;) {
		errors.push(&quot;&apos;useEslintrc&apos; must be a boolean.&quot;);
	}
	if (typeof passOnNoPatterns !== &quot;boolean&quot;) {
		errors.push(&quot;&apos;passOnNoPatterns&apos; must be a boolean.&quot;);
	}

	if (errors.length > 0) {
		throw new ESLintInvalidOptionsError(errors);
	}

	return {
		allowInlineConfig,
		baseConfig,
		cache,
		cacheLocation,
		cacheStrategy,
		configFile: overrideConfigFile,
		cwd: path.normalize(cwd),
		errorOnUnmatchedPattern,
		extensions,
		fix,
		fixTypes,
		flags: [], // LegacyESLint does not support flags, so just ignore them.
		globInputPaths,
		ignore,
		ignorePath,
		reportUnusedDisableDirectives,
		resolvePluginsRelativeTo,
		rulePaths,
		useEslintrc,
		passOnNoPatterns,
	};
}

/**
 * Check if a value has one or more properties and that value is not undefined.
 * @param {any} obj The value to check.
 * @returns {boolean} `true` if `obj` has one or more properties that value is not undefined.
 */
function hasDefinedProperty(obj) {
	if (typeof obj === &quot;object&quot; && obj !== null) {
		for (const key in obj) {
			if (typeof obj[key] !== &quot;undefined&quot;) {
				return true;
			}
		}
	}
	return false;
}

/**
 * Create rulesMeta object.
 * @param {Map<string,Rule>} rules a map of rules from which to generate the object.
 * @returns {Object} metadata for all enabled rules.
 */
function createRulesMeta(rules) {
	return Array.from(rules).reduce((retVal, [id, rule]) => {
		retVal[id] = rule.meta;
		return retVal;
	}, {});
}

/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */
const usedDeprecatedRulesCache = new WeakMap();

/**
 * Create used deprecated rule list.
 * @param {CLIEngine} cliEngine The CLIEngine instance.
 * @param {string} maybeFilePath The absolute path to a lint target file or `&quot;<text>&quot;`.
 * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.
 */
function getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {
	const {
		configArrayFactory,
		options: { cwd },
	} = getCLIEngineInternalSlots(cliEngine);
	const filePath = path.isAbsolute(maybeFilePath)
		? maybeFilePath
		: path.join(cwd, &quot;__placeholder__.js&quot;);
	const configArray = configArrayFactory.getConfigArrayForFile(filePath);
	const config = configArray.extractConfig(filePath);

	// Most files use the same config, so cache it.
	if (!usedDeprecatedRulesCache.has(config)) {
		const pluginRules = configArray.pluginRules;
		const retv = [];

		for (const [ruleId, ruleConf] of Object.entries(config.rules)) {
			if (getRuleSeverity(ruleConf) === 0) {
				continue;
			}
			const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);
			const meta = rule && rule.meta;

			if (meta && meta.deprecated) {
				retv.push({ ruleId, replacedBy: meta.replacedBy || [] });
			}
		}

		usedDeprecatedRulesCache.set(config, Object.freeze(retv));
	}

	return usedDeprecatedRulesCache.get(config);
}

/**
 * Processes the linting results generated by a CLIEngine linting report to
 * match the ESLint class&apos;s API.
 * @param {CLIEngine} cliEngine The CLIEngine instance.
 * @param {CLIEngineLintReport} report The CLIEngine linting report to process.
 * @returns {LintResult[]} The processed linting results.
 */
function processCLIEngineLintReport(cliEngine, { results }) {
	const descriptor = {
		configurable: true,
		enumerable: true,
		get() {
			return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);
		},
	};

	for (const result of results) {
		Object.defineProperty(result, &quot;usedDeprecatedRules&quot;, descriptor);
	}

	return results;
}

/**
 * An Array.prototype.sort() compatible compare function to order results by their file path.
 * @param {LintResult} a The first lint result.
 * @param {LintResult} b The second lint result.
 * @returns {number} An integer representing the order in which the two results should occur.
 */
function compareResultsByFilePath(a, b) {
	if (a.filePath < b.filePath) {
		return -1;
	}

	if (a.filePath > b.filePath) {
		return 1;
	}

	return 0;
}

/**
 * Main API.
 */
class LegacyESLint {
	/**
	 * The type of configuration used by this class.
	 * @type {string}
	 */
	static configType = &quot;eslintrc&quot;;

	/**
	 * Creates a new instance of the main ESLint API.
	 * @param {LegacyESLintOptions} options The options for this instance.
	 */
	constructor(options = {}) {
		const processedOptions = processOptions(options);
		const cliEngine = new CLIEngine(processedOptions, {
			preloadedPlugins: options.plugins,
		});
		const { configArrayFactory, lastConfigArrays } =
			getCLIEngineInternalSlots(cliEngine);
		let updated = false;

		/*
		 * Address `overrideConfig` to set override config.
		 * Operate the `configArrayFactory` internal slot directly because this
		 * functionality doesn&apos;t exist as the public API of CLIEngine.
		 */
		if (hasDefinedProperty(options.overrideConfig)) {
			configArrayFactory.setOverrideConfig(options.overrideConfig);
			updated = true;
		}

		// Update caches.
		if (updated) {
			configArrayFactory.clearCache();
			lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();
		}

		// Initialize private properties.
		privateMembersMap.set(this, {
			cliEngine,
			options: processedOptions,
		});
	}

	/**
	 * The version text.
	 * @type {string}
	 */
	static get version() {
		return version;
	}

	/**
	 * Outputs fixes from the given results to files.
	 * @param {LintResult[]} results The lint results.
	 * @returns {Promise<void>} Returns a promise that is used to track side effects.
	 */
	static async outputFixes(results) {
		if (!Array.isArray(results)) {
			throw new Error(&quot;&apos;results&apos; must be an array&quot;);
		}

		await Promise.all(
			results
				.filter(result => {
					if (typeof result !== &quot;object&quot; || result === null) {
						throw new Error(&quot;&apos;results&apos; must include only objects&quot;);
					}
					return (
						typeof result.output === &quot;string&quot; &&
						path.isAbsolute(result.filePath)
					);
				})
				.map(r => writeFile(r.filePath, r.output)),
		);
	}

	/**
	 * Returns results that only contains errors.
	 * @param {LintResult[]} results The results to filter.
	 * @returns {LintResult[]} The filtered results.
	 */
	static getErrorResults(results) {
		return CLIEngine.getErrorResults(results);
	}

	/**
	 * Returns meta objects for each rule represented in the lint results.
	 * @param {LintResult[]} results The results to fetch rules meta for.
	 * @returns {Object} A mapping of ruleIds to rule meta objects.
	 */
	getRulesMetaForResults(results) {
		const resultRuleIds = new Set();

		// first gather all ruleIds from all results

		for (const result of results) {
			for (const { ruleId } of result.messages) {
				resultRuleIds.add(ruleId);
			}
			for (const { ruleId } of result.suppressedMessages) {
				resultRuleIds.add(ruleId);
			}
		}

		// create a map of all rules in the results

		const { cliEngine } = privateMembersMap.get(this);
		const rules = cliEngine.getRules();
		const resultRules = new Map();

		for (const [ruleId, rule] of rules) {
			if (resultRuleIds.has(ruleId)) {
				resultRules.set(ruleId, rule);
			}
		}

		return createRulesMeta(resultRules);
	}

	/* eslint-disable no-unused-vars, class-methods-use-this -- leaving for compatibility with ESLint#hasFlag */
	/**
	 * Indicates if the given feature flag is enabled for this instance. For this
	 * class, this always returns `false` because it does not support feature flags.
	 * @param {string} flag The feature flag to check.
	 * @returns {boolean} Always false.
	 */
	hasFlag(flag) {
		return false;
	}
	/* eslint-enable no-unused-vars, class-methods-use-this -- reenable rules for the rest of the file */

	/**
	 * Executes the current configuration on an array of file and directory names.
	 * @param {string[]} patterns An array of file and directory names.
	 * @returns {Promise<LintResult[]>} The results of linting the file patterns given.
	 */
	async lintFiles(patterns) {
		const { cliEngine, options } = privateMembersMap.get(this);

		if (
			options.passOnNoPatterns &&
			(patterns === &quot;&quot; ||
				(Array.isArray(patterns) && patterns.length === 0))
		) {
			return [];
		}

		if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {
			throw new Error(
				&quot;&apos;patterns&apos; must be a non-empty string or an array of non-empty strings&quot;,
			);
		}

		return processCLIEngineLintReport(
			cliEngine,
			cliEngine.executeOnFiles(patterns),
		);
	}

	/**
	 * Executes the current configuration on text.
	 * @param {string} code A string of JavaScript code to lint.
	 * @param {Object} [options] The options.
	 * @param {string} [options.filePath] The path to the file of the source code.
	 * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.
	 * @returns {Promise<LintResult[]>} The results of linting the string of code given.
	 */
	async lintText(code, options = {}) {
		if (typeof code !== &quot;string&quot;) {
			throw new Error(&quot;&apos;code&apos; must be a string&quot;);
		}
		if (typeof options !== &quot;object&quot;) {
			throw new Error(&quot;&apos;options&apos; must be an object, null, or undefined&quot;);
		}
		const {
			filePath,
			warnIgnored = false,
			...unknownOptions
		} = options || {};

		const unknownOptionKeys = Object.keys(unknownOptions);

		if (unknownOptionKeys.length > 0) {
			throw new Error(
				`&apos;options&apos; must not include the unknown option(s): ${unknownOptionKeys.join(&quot;, &quot;)}`,
			);
		}

		if (filePath !== void 0 && !isNonEmptyString(filePath)) {
			throw new Error(
				&quot;&apos;options.filePath&apos; must be a non-empty string or undefined&quot;,
			);
		}
		if (typeof warnIgnored !== &quot;boolean&quot;) {
			throw new Error(
				&quot;&apos;options.warnIgnored&apos; must be a boolean or undefined&quot;,
			);
		}

		const { cliEngine } = privateMembersMap.get(this);

		return processCLIEngineLintReport(
			cliEngine,
			cliEngine.executeOnText(code, filePath, warnIgnored),
		);
	}

	/**
	 * Returns the formatter representing the given formatter name.
	 * @param {string} [name] The name of the formatter to load.
	 * The following values are allowed:
	 * - `undefined` ... Load `stylish` builtin formatter.
	 * - A builtin formatter name ... Load the builtin formatter.
	 * - A third-party formatter name:
	 *   - `foo` → `eslint-formatter-foo`
	 *   - `@foo` → `@foo/eslint-formatter`
	 *   - `@foo/bar` → `@foo/eslint-formatter-bar`
	 * - A file path ... Load the file.
	 * @returns {Promise<LoadedFormatter>} A promise resolving to the formatter object.
	 * This promise will be rejected if the given formatter was not found or not
	 * a function.
	 */
	async loadFormatter(name = &quot;stylish&quot;) {
		if (typeof name !== &quot;string&quot;) {
			throw new Error(&quot;&apos;name&apos; must be a string&quot;);
		}

		const { cliEngine, options } = privateMembersMap.get(this);
		const formatter = cliEngine.getFormatter(name);

		if (typeof formatter !== &quot;function&quot;) {
			throw new Error(
				`Formatter must be a function, but got a ${typeof formatter}.`,
			);
		}

		return {
			/**
			 * The main formatter method.
			 * @param {LintResult[]} results The lint results to format.
			 * @param {ResultsMeta} resultsMeta Warning count and max threshold.
			 * @returns {string | Promise<string>} The formatted lint results.
			 */
			format(results, resultsMeta) {
				let rulesMeta = null;

				results.sort(compareResultsByFilePath);

				return formatter(results, {
					...resultsMeta,
					get cwd() {
						return options.cwd;
					},
					get rulesMeta() {
						if (!rulesMeta) {
							rulesMeta = createRulesMeta(cliEngine.getRules());
						}

						return rulesMeta;
					},
				});
			},
		};
	}

	/**
	 * Returns a configuration object for the given file based on the CLI options.
	 * This is the same logic used by the ESLint CLI executable to determine
	 * configuration for each file it processes.
	 * @param {string} filePath The path of the file to retrieve a config object for.
	 * @returns {Promise<ConfigData>} A configuration object for the file.
	 */
	async calculateConfigForFile(filePath) {
		if (!isNonEmptyString(filePath)) {
			throw new Error(&quot;&apos;filePath&apos; must be a non-empty string&quot;);
		}
		const { cliEngine } = privateMembersMap.get(this);

		return cliEngine.getConfigForFile(filePath);
	}

	/**
	 * Checks if a given path is ignored by ESLint.
	 * @param {string} filePath The path of the file to check.
	 * @returns {Promise<boolean>} Whether or not the given path is ignored.
	 */
	async isPathIgnored(filePath) {
		if (!isNonEmptyString(filePath)) {
			throw new Error("'filePath' must be a non-empty string");
		}
		const { cliEngine } = privateMembersMap.get(this);

		return cliEngine.isPathIgnored(filePath);
	}
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
	LegacyESLint,

	/**
	 * Get the private class members of a given ESLint instance for tests.
	 * @param {ESLint} instance The ESLint instance to get.
	 * @returns {ESLintPrivateMembers} The instance's private class members.
	 */
	getESLintPrivateMembers(instance) {
		return privateMembersMap.get(instance);
	},
};
