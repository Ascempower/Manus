/**
 * @fileoverview Check if tag attributes to have non-valid value
 * @author Sebastian Malton
 */

'use strict';

const matchAll = require('string.prototype.matchall');
const docsUrl = require('../util/docsUrl');
const report = require('../util/report');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const rel = new Map([
  ['alternate', new Set(['link', 'area', 'a'])],
  ['apple-touch-icon', new Set(['link'])],
  ['apple-touch-startup-image', new Set(['link'])],
  ['author', new Set(['link', 'area', 'a'])],
  ['bookmark', new Set(['area', 'a'])],
  ['canonical', new Set(['link'])],
  ['dns-prefetch', new Set(['link'])],
  ['external', new Set(['area', 'a', 'form'])],
  ['help', new Set(['link', 'area', 'a', 'form'])],
  ['icon', new Set(['link'])],
  ['license', new Set(['link', 'area', 'a', 'form'])],
  ['manifest', new Set(['link'])],
  ['mask-icon', new Set(['link'])],
  ['modulepreload', new Set(['link'])],
  ['next', new Set(['link', 'area', 'a', 'form'])],
  ['nofollow', new Set(['area', 'a', 'form'])],
  ['noopener', new Set(['area', 'a', 'form'])],
  ['noreferrer', new Set(['area', 'a', 'form'])],
  ['opener', new Set(['area', 'a', 'form'])],
  ['pingback', new Set(['link'])],
  ['preconnect', new Set(['link'])],
  ['prefetch', new Set(['link'])],
  ['preload', new Set(['link'])],
  ['prerender', new Set(['link'])],
  ['prev', new Set(['link', 'area', 'a', 'form'])],
  ['search', new Set(['link', 'area', 'a', 'form'])],
  ['shortcut', new Set(['link'])], // generally allowed but needs pair with "icon"
  ['shortcut\u0020icon', new Set(['link'])],
  ['stylesheet', new Set(['link'])],
  ['tag', new Set(['area', 'a'])],
]);

const pairs = new Map([
  ['shortcut', new Set(['icon'])],
]);

/**
 * Map between attributes and a mapping between valid values and a set of tags they are valid on
 * @type {Map<string, Map<string, Set<string>>>}
 */
const VALID_VALUES = new Map([
  [&apos;rel&apos;, rel],
]);

/**
 * Map between attributes and a mapping between pair-values and a set of values they are valid with
 * @type {Map<string, Map<string, Set<string>>>}
 */
const VALID_PAIR_VALUES = new Map([
  [&apos;rel&apos;, pairs],
]);

/**
 * The set of all possible HTML elements. Used for skipping custom types
 * @type {Set<string>}
 */
const HTML_ELEMENTS = new Set([
  &apos;a&apos;,
  &apos;abbr&apos;,
  &apos;acronym&apos;,
  &apos;address&apos;,
  &apos;applet&apos;,
  &apos;area&apos;,
  &apos;article&apos;,
  &apos;aside&apos;,
  &apos;audio&apos;,
  &apos;b&apos;,
  &apos;base&apos;,
  &apos;basefont&apos;,
  &apos;bdi&apos;,
  &apos;bdo&apos;,
  &apos;bgsound&apos;,
  &apos;big&apos;,
  &apos;blink&apos;,
  &apos;blockquote&apos;,
  &apos;body&apos;,
  &apos;br&apos;,
  &apos;button&apos;,
  &apos;canvas&apos;,
  &apos;caption&apos;,
  &apos;center&apos;,
  &apos;cite&apos;,
  &apos;code&apos;,
  &apos;col&apos;,
  &apos;colgroup&apos;,
  &apos;content&apos;,
  &apos;data&apos;,
  &apos;datalist&apos;,
  &apos;dd&apos;,
  &apos;del&apos;,
  &apos;details&apos;,
  &apos;dfn&apos;,
  &apos;dialog&apos;,
  &apos;dir&apos;,
  &apos;div&apos;,
  &apos;dl&apos;,
  &apos;dt&apos;,
  &apos;em&apos;,
  &apos;embed&apos;,
  &apos;fieldset&apos;,
  &apos;figcaption&apos;,
  &apos;figure&apos;,
  &apos;font&apos;,
  &apos;footer&apos;,
  &apos;form&apos;,
  &apos;frame&apos;,
  &apos;frameset&apos;,
  &apos;h1&apos;,
  &apos;h2&apos;,
  &apos;h3&apos;,
  &apos;h4&apos;,
  &apos;h5&apos;,
  &apos;h6&apos;,
  &apos;head&apos;,
  &apos;header&apos;,
  &apos;hgroup&apos;,
  &apos;hr&apos;,
  &apos;html&apos;,
  &apos;i&apos;,
  &apos;iframe&apos;,
  &apos;image&apos;,
  &apos;img&apos;,
  &apos;input&apos;,
  &apos;ins&apos;,
  &apos;kbd&apos;,
  &apos;keygen&apos;,
  &apos;label&apos;,
  &apos;legend&apos;,
  &apos;li&apos;,
  &apos;link&apos;,
  &apos;main&apos;,
  &apos;map&apos;,
  &apos;mark&apos;,
  &apos;marquee&apos;,
  &apos;math&apos;,
  &apos;menu&apos;,
  &apos;menuitem&apos;,
  &apos;meta&apos;,
  &apos;meter&apos;,
  &apos;nav&apos;,
  &apos;nobr&apos;,
  &apos;noembed&apos;,
  &apos;noframes&apos;,
  &apos;noscript&apos;,
  &apos;object&apos;,
  &apos;ol&apos;,
  &apos;optgroup&apos;,
  &apos;option&apos;,
  &apos;output&apos;,
  &apos;p&apos;,
  &apos;param&apos;,
  &apos;picture&apos;,
  &apos;plaintext&apos;,
  &apos;portal&apos;,
  &apos;pre&apos;,
  &apos;progress&apos;,
  &apos;q&apos;,
  &apos;rb&apos;,
  &apos;rp&apos;,
  &apos;rt&apos;,
  &apos;rtc&apos;,
  &apos;ruby&apos;,
  &apos;s&apos;,
  &apos;samp&apos;,
  &apos;script&apos;,
  &apos;section&apos;,
  &apos;select&apos;,
  &apos;shadow&apos;,
  &apos;slot&apos;,
  &apos;small&apos;,
  &apos;source&apos;,
  &apos;spacer&apos;,
  &apos;span&apos;,
  &apos;strike&apos;,
  &apos;strong&apos;,
  &apos;style&apos;,
  &apos;sub&apos;,
  &apos;summary&apos;,
  &apos;sup&apos;,
  &apos;svg&apos;,
  &apos;table&apos;,
  &apos;tbody&apos;,
  &apos;td&apos;,
  &apos;template&apos;,
  &apos;textarea&apos;,
  &apos;tfoot&apos;,
  &apos;th&apos;,
  &apos;thead&apos;,
  &apos;time&apos;,
  &apos;title&apos;,
  &apos;tr&apos;,
  &apos;track&apos;,
  &apos;tt&apos;,
  &apos;u&apos;,
  &apos;ul&apos;,
  &apos;var&apos;,
  &apos;video&apos;,
  &apos;wbr&apos;,
  &apos;xmp&apos;,
]);

/**
* Map between attributes and set of tags that the attribute is valid on
* @type {Map<string, Set<string>>}
*/
const COMPONENT_ATTRIBUTE_MAP = new Map([
  [&apos;rel&apos;, new Set([&apos;link&apos;, &apos;a&apos;, &apos;area&apos;, &apos;form&apos;])],
]);

/* eslint-disable eslint-plugin/no-unused-message-ids -- false positives, these messageIds are used */
const messages = {
  emptyIsMeaningless: &apos;An empty “{{attributeName}}” attribute is meaningless.&apos;,
  neverValid: &apos;“{{reportingValue}}” is never a valid “{{attributeName}}” attribute value.&apos;,
  noEmpty: &apos;An empty “{{attributeName}}” attribute is meaningless.&apos;,
  noMethod: &apos;The ”{{attributeName}}“ attribute cannot be a method.&apos;,
  notAlone: &apos;“{{reportingValue}}” must be directly followed by “{{missingValue}}”.&apos;,
  notPaired: &apos;“{{reportingValue}}” can not be directly followed by “{{secondValue}}” without “{{missingValue}}”.&apos;,
  notValidFor: &apos;“{{reportingValue}}” is not a valid “{{attributeName}}” attribute value for <{{elementName}}>.&apos;,
  onlyMeaningfulFor: &apos;The ”{{attributeName}}“ attribute only has meaning on the tags: {{tagNames}}&apos;,
  onlyStrings: &apos;“{{attributeName}}” attribute only supports strings.&apos;,
  spaceDelimited: &apos;”{{attributeName}}“ attribute values should be space delimited.&apos;,
  suggestRemoveDefault: &apos;&quot;remove {{attributeName}}&quot;&apos;,
  suggestRemoveEmpty: &apos;&quot;remove empty attribute {{attributeName}}&quot;&apos;,
  suggestRemoveInvalid: &apos;“remove invalid attribute {{reportingValue}}”&apos;,
  suggestRemoveWhitespaces: &apos;remove whitespaces in “{{attributeName}}”&apos;,
  suggestRemoveNonString: &apos;remove non-string value in “{{attributeName}}”&apos;,
};

function splitIntoRangedParts(node, regex) {
  const valueRangeStart = node.range[0] + 1; // the plus one is for the initial quote

  return Array.from(matchAll(node.value, regex), (match) => {
    const start = match.index + valueRangeStart;
    const end = start + match[0].length;

    return {
      reportingValue: `${match[1]}`,
      value: match[1],
      range: [start, end],
    };
  });
}

function checkLiteralValueNode(context, attributeName, node, parentNode, parentNodeName) {
  if (typeof node.value !== &apos;string&apos;) {
    const data = { attributeName, reportingValue: node.value };

    report(context, messages.onlyStrings, &apos;onlyStrings&apos;, {
      node,
      data,
      suggest: [{
        messageId: &apos;suggestRemoveNonString&apos;,
        data,
        fix(fixer) { return fixer.remove(parentNode); },
      }],
    });
    return;
  }

  if (!node.value.trim()) {
    const data = { attributeName, reportingValue: node.value };

    report(context, messages.noEmpty, &apos;noEmpty&apos;, {
      node,
      data,
      suggest: [{
        messageId: &apos;suggestRemoveEmpty&apos;,
        data,
        fix(fixer) { return fixer.remove(node.parent); },
      }],
    });
    return;
  }

  const singleAttributeParts = splitIntoRangedParts(node, /(\S+)/g);
  singleAttributeParts.forEach((singlePart) => {
    const allowedTags = VALID_VALUES.get(attributeName).get(singlePart.value);
    const reportingValue = singlePart.reportingValue;

    if (!allowedTags) {
      const data = {
        attributeName,
        reportingValue,
      };

      const suggest = [{
        messageId: &apos;suggestRemoveInvalid&apos;,
        data,
        fix(fixer) { return fixer.removeRange(singlePart.range); },
      }];

      report(context, messages.neverValid, &apos;neverValid&apos;, {
        node,
        data,
        suggest,
      });
    } else if (!allowedTags.has(parentNodeName)) {
      const data = {
        attributeName,
        reportingValue,
        elementName: parentNodeName,
      };

      const suggest = [{
        messageId: &apos;suggestRemoveInvalid&apos;,
        data,
        fix(fixer) { return fixer.removeRange(singlePart.range); },
      }];

      report(context, messages.notValidFor, &apos;notValidFor&apos;, {
        node,
        data,
        suggest,
      });
    }
  });

  const allowedPairsForAttribute = VALID_PAIR_VALUES.get(attributeName);
  if (allowedPairsForAttribute) {
    const pairAttributeParts = splitIntoRangedParts(node, /(?=(\b\S+\s*\S+))/g);
    pairAttributeParts.forEach((pairPart) => {
      allowedPairsForAttribute.forEach((siblings, pairing) => {
        const attributes = pairPart.reportingValue.split(&apos;\u0020&apos;);
        const firstValue = attributes[0];
        const secondValue = attributes[1];
        if (firstValue === pairing) {
          const lastValue = attributes[attributes.length - 1]; // in case of multiple white spaces
          if (!siblings.has(lastValue)) {
            const message = secondValue ? messages.notPaired : messages.notAlone;
            const messageId = secondValue ? &apos;notPaired&apos; : &apos;notAlone&apos;;
            report(context, message, messageId, {
              node,
              data: {
                reportingValue: firstValue,
                secondValue,
                missingValue: Array.from(siblings).join(&apos;, &apos;),
              },
              suggest: false,
            });
          }
        }
      });
    });
  }

  const whitespaceParts = splitIntoRangedParts(node, /(\s+)/g);
  whitespaceParts.forEach((whitespacePart) => {
    const data = { attributeName };

    if (whitespacePart.range[0] === (node.range[0] + 1) || whitespacePart.range[1] === (node.range[1] - 1)) {
      report(context, messages.spaceDelimited, &apos;spaceDelimited&apos;, {
        node,
        data,
        suggest: [{
          messageId: &apos;suggestRemoveWhitespaces&apos;,
          data,
          fix(fixer) { return fixer.removeRange(whitespacePart.range); },
        }],
      });
    } else if (whitespacePart.value !== &apos;\u0020&apos;) {
      report(context, messages.spaceDelimited, &apos;spaceDelimited&apos;, {
        node,
        data,
        suggest: [{
          messageId: &apos;suggestRemoveWhitespaces&apos;,
          data,
          fix(fixer) { return fixer.replaceTextRange(whitespacePart.range, &apos;\u0020&apos;); },
        }],
      });
    }
  });
}

const DEFAULT_ATTRIBUTES = [&apos;rel&apos;];

function checkAttribute(context, node) {
  const attribute = node.name.name;

  const parentNodeName = node.parent.name.name;
  if (!COMPONENT_ATTRIBUTE_MAP.has(attribute) || !COMPONENT_ATTRIBUTE_MAP.get(attribute).has(parentNodeName)) {
    const tagNames = Array.from(
      COMPONENT_ATTRIBUTE_MAP.get(attribute).values(),
      (tagName) => `&quot;<${tagName}>&quot;`
    ).join(&apos;, &apos;);
    const data = {
      attributeName: attribute,
      tagNames,
    };

    report(context, messages.onlyMeaningfulFor, &apos;onlyMeaningfulFor&apos;, {
      node: node.name,
      data,
      suggest: [{
        messageId: &apos;suggestRemoveDefault&apos;,
        data,
        fix(fixer) { return fixer.remove(node); },
      }],
    });
    return;
  }

  function fix(fixer) { return fixer.remove(node); }

  if (!node.value) {
    const data = { attributeName: attribute };

    report(context, messages.emptyIsMeaningless, &apos;emptyIsMeaningless&apos;, {
      node: node.name,
      data,
      suggest: [{
        messageId: &apos;suggestRemoveEmpty&apos;,
        data,
        fix,
      }],
    });
    return;
  }

  if (node.value.type === &apos;Literal&apos;) {
    return checkLiteralValueNode(context, attribute, node.value, node, parentNodeName);
  }

  if (node.value.expression.type === &apos;Literal&apos;) {
    return checkLiteralValueNode(context, attribute, node.value.expression, node, parentNodeName);
  }

  if (node.value.type !== &apos;JSXExpressionContainer&apos;) {
    return;
  }

  if (node.value.expression.type === &apos;ObjectExpression&apos;) {
    const data = { attributeName: attribute };

    report(context, messages.onlyStrings, &apos;onlyStrings&apos;, {
      node: node.value,
      data,
      suggest: [{
        messageId: &apos;suggestRemoveDefault&apos;,
        data,
        fix,
      }],
    });
  } else if (node.value.expression.type === &apos;Identifier&apos; && node.value.expression.name === &apos;undefined&apos;) {
    const data = { attributeName: attribute };

    report(context, messages.onlyStrings, &apos;onlyStrings&apos;, {
      node: node.value,
      data,
      suggest: [{
        messageId: &apos;suggestRemoveDefault&apos;,
        data,
        fix,
      }],
    });
  }
}

function isValidCreateElement(node) {
  return node.callee
    && node.callee.type === &apos;MemberExpression&apos;
    && node.callee.object.name === &apos;React&apos;
    && node.callee.property.name === &apos;createElement&apos;
    && node.arguments.length > 0;
}

function checkPropValidValue(context, node, value, attribute) {
  const validTags = VALID_VALUES.get(attribute);

  if (value.type !== &apos;Literal&apos;) {
    return; // cannot check non-literals
  }

  const validTagSet = validTags.get(value.value);
  if (!validTagSet) {
    const data = {
      attributeName: attribute,
      reportingValue: value.value,
    };

    report(context, messages.neverValid, &apos;neverValid&apos;, {
      node: value,
      data,
      suggest: [{
        messageId: &apos;suggestRemoveInvalid&apos;,
        data,
        fix(fixer) { return fixer.replaceText(value, value.raw.replace(value.value, &apos;&apos;)); },
      }],
    });
  } else if (!validTagSet.has(node.arguments[0].value)) {
    report(context, messages.notValidFor, &apos;notValidFor&apos;, {
      node: value,
      data: {
        attributeName: attribute,
        reportingValue: value.raw,
        elementName: node.arguments[0].value,
      },
      suggest: false,
    });
  }
}

/**
 *
 * @param {*} context
 * @param {*} node
 * @param {string} attribute
 */
function checkCreateProps(context, node, attribute) {
  const propsArg = node.arguments[1];

  if (!propsArg || propsArg.type !== &apos;ObjectExpression&apos;) {
    return; // can&apos;t check variables, computed, or shorthands
  }

  for (const prop of propsArg.properties) {
    if (!prop.key || prop.key.type !== &apos;Identifier&apos;) {
      // eslint-disable-next-line no-continue
      continue; // cannot check computed keys
    }

    if (prop.key.name !== attribute) {
      // eslint-disable-next-line no-continue
      continue; // ignore not this attribute
    }

    if (!COMPONENT_ATTRIBUTE_MAP.get(attribute).has(node.arguments[0].value)) {
      const tagNames = Array.from(
        COMPONENT_ATTRIBUTE_MAP.get(attribute).values(),
        (tagName) => `&quot;<${tagName}>"`
      ).join(', ');

      report(context, messages.onlyMeaningfulFor, 'onlyMeaningfulFor', {
        node: prop.key,
        data: {
          attributeName: attribute,
          tagNames,
        },
        suggest: false,
      });

      // eslint-disable-next-line no-continue
      continue;
    }

    if (prop.method) {
      report(context, messages.noMethod, 'noMethod', {
        node: prop,
        data: {
          attributeName: attribute,
        },
        suggest: false,
      });

      // eslint-disable-next-line no-continue
      continue;
    }

    if (prop.shorthand || prop.computed) {
      // eslint-disable-next-line no-continue
      continue; // cannot check these
    }

    if (prop.value.type === 'ArrayExpression') {
      prop.value.elements.forEach((value) => {
        checkPropValidValue(context, node, value, attribute);
      });

      // eslint-disable-next-line no-continue
      continue;
    }

    checkPropValidValue(context, node, prop.value, attribute);
  }
}

/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    docs: {
      description: 'Disallow usage of invalid attributes',
      category: 'Possible Errors',
      url: docsUrl('no-invalid-html-attribute'),
    },
    messages,
    schema: [{
      type: 'array',
      uniqueItems: true,
      items: {
        enum: ['rel'],
      },
    }],
    type: 'suggestion',
    hasSuggestions: true, // eslint-disable-line eslint-plugin/require-meta-has-suggestions
  },

  create(context) {
    return {
      JSXAttribute(node) {
        const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES);

        // ignore attributes that aren't configured to be checked
        if (!attributes.has(node.name.name)) {
          return;
        }

        // ignore non-HTML elements
        if (!HTML_ELEMENTS.has(node.parent.name.name)) {
          return;
        }

        checkAttribute(context, node);
      },

      CallExpression(node) {
        if (!isValidCreateElement(node)) {
          return;
        }

        const elemNameArg = node.arguments[0];

        if (!elemNameArg || elemNameArg.type !== 'Literal') {
          return; // can only check literals
        }

        // ignore non-HTML elements
        if (typeof elemNameArg.value === 'string' && !HTML_ELEMENTS.has(elemNameArg.value)) {
          return;
        }

        const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES);

        attributes.forEach((attribute) => {
          checkCreateProps(context, node, attribute);
        });
      },
    };
  },
};
