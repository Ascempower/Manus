#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _path = /*#__PURE__*/ _interop_require_default(require("path"));
const _arg = /*#__PURE__*/ _interop_require_default(require("arg"));
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _build = require("./build");
const _help = require("./help");
const _init = require("./init");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function oneOf(...options) {
    return Object.assign((value = true)=>{
        for (let option of options){
            let parsed = option(value);
            if (parsed === value) {
                return parsed;
            }
        }
        throw new Error(&quot;...&quot;);
    }, {
        manualParsing: true
    });
}
let commands = {
    init: {
        run: _init.init,
        args: {
            &quot;--esm&quot;: {
                type: Boolean,
                description: `Initialize configuration file as ESM`
            },
            &quot;--ts&quot;: {
                type: Boolean,
                description: `Initialize configuration file as TypeScript`
            },
            &quot;--postcss&quot;: {
                type: Boolean,
                description: `Initialize a \`postcss.config.js\` file`
            },
            &quot;--full&quot;: {
                type: Boolean,
                description: `Include the default values for all options in the generated configuration file`
            },
            &quot;-f&quot;: &quot;--full&quot;,
            &quot;-p&quot;: &quot;--postcss&quot;
        }
    },
    build: {
        run: _build.build,
        args: {
            &quot;--input&quot;: {
                type: String,
                description: &quot;Input file&quot;
            },
            &quot;--output&quot;: {
                type: String,
                description: &quot;Output file&quot;
            },
            &quot;--watch&quot;: {
                type: oneOf(String, Boolean),
                description: &quot;Watch for changes and rebuild as needed&quot;
            },
            &quot;--poll&quot;: {
                type: Boolean,
                description: &quot;Use polling instead of filesystem events when watching&quot;
            },
            &quot;--content&quot;: {
                type: String,
                description: &quot;Content paths to use for removing unused classes&quot;
            },
            &quot;--purge&quot;: {
                type: String,
                deprecated: true
            },
            &quot;--postcss&quot;: {
                type: oneOf(String, Boolean),
                description: &quot;Load custom PostCSS configuration&quot;
            },
            &quot;--minify&quot;: {
                type: Boolean,
                description: &quot;Minify the output&quot;
            },
            &quot;--config&quot;: {
                type: String,
                description: &quot;Path to a custom config file&quot;
            },
            &quot;--no-autoprefixer&quot;: {
                type: Boolean,
                description: &quot;Disable autoprefixer&quot;
            },
            &quot;-c&quot;: &quot;--config&quot;,
            &quot;-i&quot;: &quot;--input&quot;,
            &quot;-o&quot;: &quot;--output&quot;,
            &quot;-m&quot;: &quot;--minify&quot;,
            &quot;-w&quot;: &quot;--watch&quot;,
            &quot;-p&quot;: &quot;--poll&quot;
        }
    }
};
let sharedFlags = {
    &quot;--help&quot;: {
        type: Boolean,
        description: &quot;Display usage information&quot;
    },
    &quot;-h&quot;: &quot;--help&quot;
};
if (process.stdout.isTTY /* Detect redirecting output to a file */  && (process.argv[2] === undefined || process.argv.slice(2).every((flag)=>sharedFlags[flag] !== undefined))) {
    (0, _help.help)({
        usage: [
            &quot;tailwindcss [--input input.css] [--output output.css] [--watch] [options...]&quot;,
            &quot;tailwindcss init [--full] [--postcss] [options...]&quot;
        ],
        commands: Object.keys(commands).filter((command)=>command !== &quot;build&quot;).map((command)=>`${command} [options]`),
        options: {
            ...commands.build.args,
            ...sharedFlags
        }
    });
    process.exit(0);
}
let command = ((arg = &quot;&quot;)=>arg.startsWith(&quot;-&quot;) ? undefined : arg)(process.argv[2]) || &quot;build&quot;;
if (commands[command] === undefined) {
    if (_fs.default.existsSync(_path.default.resolve(command))) {
        // TODO: Deprecate this in future versions
        // Check if non-existing command, might be a file.
        command = &quot;build&quot;;
    } else {
        (0, _help.help)({
            message: `Invalid command: ${command}`,
            usage: [
                &quot;tailwindcss <command> [options]&quot;
            ],
            commands: Object.keys(commands).filter((command)=>command !== &quot;build&quot;).map((command)=>`${command} [options]`),
            options: sharedFlags
        });
        process.exit(1);
    }
}
// Execute command
let { args: flags , run  } = commands[command];
let args = (()=>{
    try {
        let result = (0, _arg.default)(Object.fromEntries(Object.entries({
            ...flags,
            ...sharedFlags
        }).filter(([_key, value])=>{
            var _value_type;
            return !(value === null || value === void 0 ? void 0 : (_value_type = value.type) === null || _value_type === void 0 ? void 0 : _value_type.manualParsing);
        }).map(([key, value])=>[
                key,
                typeof value === &quot;object&quot; ? value.type : value
            ])), {
            permissive: true
        });
        // Manual parsing of flags to allow for special flags like oneOf(Boolean, String)
        for(let i = result[&quot;_&quot;].length - 1; i >= 0; --i){
            let flag = result[&quot;_&quot;][i];
            if (!flag.startsWith(&quot;-&quot;)) continue;
            let [flagName, flagValue] = flag.split(&quot;=&quot;);
            let handler = flags[flagName];
            // Resolve flagName & handler
            while(typeof handler === &quot;string&quot;){
                flagName = handler;
                handler = flags[handler];
            }
            if (!handler) continue;
            let args = [];
            let offset = i + 1;
            // --flag value syntax was used so we need to pull `value` from `args`
            if (flagValue === undefined) {
                // Parse args for current flag
                while(result[&quot;_&quot;][offset] && !result[&quot;_&quot;][offset].startsWith(&quot;-&quot;)){
                    args.push(result[&quot;_&quot;][offset++]);
                }
                // Cleanup manually parsed flags + args
                result[&quot;_&quot;].splice(i, 1 + args.length);
                // No args were provided, use default value defined in handler
                // One arg was provided, use that directly
                // Multiple args were provided so pass them all in an array
                flagValue = args.length === 0 ? undefined : args.length === 1 ? args[0] : args;
            } else {
                // Remove the whole flag from the args array
                result[&quot;_&quot;].splice(i, 1);
            }
            // Set the resolved value in the `result` object
            result[flagName] = handler.type(flagValue, flagName);
        }
        // Ensure that the `command` is always the first argument in the `args`.
        // This is important so that we don&apos;t have to check if a default command
        // (build) was used or not from within each plugin.
        //
        // E.g.: tailwindcss input.css -> _: [&apos;build&apos;, &apos;input.css&apos;]
        // E.g.: tailwindcss build input.css -> _: [&apos;build&apos;, &apos;input.css&apos;]
        if (result[&quot;_&quot;][0] !== command) {
            result[&quot;_&quot;].unshift(command);
        }
        return result;
    } catch (err) {
        if (err.code === &quot;ARG_UNKNOWN_OPTION&quot;) {
            (0, _help.help)({
                message: err.message,
                usage: [
                    &quot;tailwindcss <command> [options]"
                ],
                options: sharedFlags
            });
            process.exit(1);
        }
        throw err;
    }
})();
if (args["--help"]) {
    (0, _help.help)({
        options: {
            ...flags,
            ...sharedFlags
        },
        usage: [
            `tailwindcss ${command} [options]`
        ]
    });
    process.exit(0);
}
run(args);
