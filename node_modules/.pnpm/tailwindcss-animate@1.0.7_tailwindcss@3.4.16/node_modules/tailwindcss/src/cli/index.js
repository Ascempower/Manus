#!/usr/bin/env node

import path from 'path'
import arg from 'arg'
import fs from 'fs'

import { build } from './build'
import { help } from './help'
import { init } from './init'

function oneOf(...options) {
  return Object.assign(
    (value = true) => {
      for (let option of options) {
        let parsed = option(value)
        if (parsed === value) {
          return parsed
        }
      }

      throw new Error(&apos;...&apos;)
    },
    { manualParsing: true }
  )
}

let commands = {
  init: {
    run: init,
    args: {
      &apos;--esm&apos;: { type: Boolean, description: `Initialize configuration file as ESM` },
      &apos;--ts&apos;: { type: Boolean, description: `Initialize configuration file as TypeScript` },
      &apos;--postcss&apos;: { type: Boolean, description: `Initialize a \`postcss.config.js\` file` },
      &apos;--full&apos;: {
        type: Boolean,
        description: `Include the default values for all options in the generated configuration file`,
      },
      &apos;-f&apos;: &apos;--full&apos;,
      &apos;-p&apos;: &apos;--postcss&apos;,
    },
  },
  build: {
    run: build,
    args: {
      &apos;--input&apos;: { type: String, description: &apos;Input file&apos; },
      &apos;--output&apos;: { type: String, description: &apos;Output file&apos; },
      &apos;--watch&apos;: {
        type: oneOf(String, Boolean),
        description: &apos;Watch for changes and rebuild as needed&apos;,
      },
      &apos;--poll&apos;: {
        type: Boolean,
        description: &apos;Use polling instead of filesystem events when watching&apos;,
      },
      &apos;--content&apos;: {
        type: String,
        description: &apos;Content paths to use for removing unused classes&apos;,
      },
      &apos;--purge&apos;: {
        type: String,
        deprecated: true,
      },
      &apos;--postcss&apos;: {
        type: oneOf(String, Boolean),
        description: &apos;Load custom PostCSS configuration&apos;,
      },
      &apos;--minify&apos;: { type: Boolean, description: &apos;Minify the output&apos; },
      &apos;--config&apos;: {
        type: String,
        description: &apos;Path to a custom config file&apos;,
      },
      &apos;--no-autoprefixer&apos;: {
        type: Boolean,
        description: &apos;Disable autoprefixer&apos;,
      },
      &apos;-c&apos;: &apos;--config&apos;,
      &apos;-i&apos;: &apos;--input&apos;,
      &apos;-o&apos;: &apos;--output&apos;,
      &apos;-m&apos;: &apos;--minify&apos;,
      &apos;-w&apos;: &apos;--watch&apos;,
      &apos;-p&apos;: &apos;--poll&apos;,
    },
  },
}

let sharedFlags = {
  &apos;--help&apos;: { type: Boolean, description: &apos;Display usage information&apos; },
  &apos;-h&apos;: &apos;--help&apos;,
}

if (
  process.stdout.isTTY /* Detect redirecting output to a file */ &&
  (process.argv[2] === undefined ||
    process.argv.slice(2).every((flag) => sharedFlags[flag] !== undefined))
) {
  help({
    usage: [
      &apos;tailwindcss [--input input.css] [--output output.css] [--watch] [options...]&apos;,
      &apos;tailwindcss init [--full] [--postcss] [options...]&apos;,
    ],
    commands: Object.keys(commands)
      .filter((command) => command !== &apos;build&apos;)
      .map((command) => `${command} [options]`),
    options: { ...commands.build.args, ...sharedFlags },
  })
  process.exit(0)
}

let command = ((arg = &apos;&apos;) => (arg.startsWith(&apos;-&apos;) ? undefined : arg))(process.argv[2]) || &apos;build&apos;

if (commands[command] === undefined) {
  if (fs.existsSync(path.resolve(command))) {
    // TODO: Deprecate this in future versions
    // Check if non-existing command, might be a file.
    command = &apos;build&apos;
  } else {
    help({
      message: `Invalid command: ${command}`,
      usage: [&apos;tailwindcss <command> [options]&apos;],
      commands: Object.keys(commands)
        .filter((command) => command !== &apos;build&apos;)
        .map((command) => `${command} [options]`),
      options: sharedFlags,
    })
    process.exit(1)
  }
}

// Execute command
let { args: flags, run } = commands[command]
let args = (() => {
  try {
    let result = arg(
      Object.fromEntries(
        Object.entries({ ...flags, ...sharedFlags })
          .filter(([_key, value]) => !value?.type?.manualParsing)
          .map(([key, value]) => [key, typeof value === &apos;object&apos; ? value.type : value])
      ),
      { permissive: true }
    )

    // Manual parsing of flags to allow for special flags like oneOf(Boolean, String)
    for (let i = result[&apos;_&apos;].length - 1; i >= 0; --i) {
      let flag = result[&apos;_&apos;][i]
      if (!flag.startsWith(&apos;-&apos;)) continue

      let [flagName, flagValue] = flag.split(&apos;=&apos;)
      let handler = flags[flagName]

      // Resolve flagName & handler
      while (typeof handler === &apos;string&apos;) {
        flagName = handler
        handler = flags[handler]
      }

      if (!handler) continue

      let args = []
      let offset = i + 1

      // --flag value syntax was used so we need to pull `value` from `args`
      if (flagValue === undefined) {
        // Parse args for current flag
        while (result[&apos;_&apos;][offset] && !result[&apos;_&apos;][offset].startsWith(&apos;-&apos;)) {
          args.push(result[&apos;_&apos;][offset++])
        }

        // Cleanup manually parsed flags + args
        result[&apos;_&apos;].splice(i, 1 + args.length)

        // No args were provided, use default value defined in handler
        // One arg was provided, use that directly
        // Multiple args were provided so pass them all in an array
        flagValue = args.length === 0 ? undefined : args.length === 1 ? args[0] : args
      } else {
        // Remove the whole flag from the args array
        result[&apos;_&apos;].splice(i, 1)
      }

      // Set the resolved value in the `result` object
      result[flagName] = handler.type(flagValue, flagName)
    }

    // Ensure that the `command` is always the first argument in the `args`.
    // This is important so that we don&apos;t have to check if a default command
    // (build) was used or not from within each plugin.
    //
    // E.g.: tailwindcss input.css -> _: [&apos;build&apos;, &apos;input.css&apos;]
    // E.g.: tailwindcss build input.css -> _: [&apos;build&apos;, &apos;input.css&apos;]
    if (result[&apos;_&apos;][0] !== command) {
      result[&apos;_&apos;].unshift(command)
    }

    return result
  } catch (err) {
    if (err.code === &apos;ARG_UNKNOWN_OPTION&apos;) {
      help({
        message: err.message,
        usage: [&apos;tailwindcss <command> [options]'],
        options: sharedFlags,
      })
      process.exit(1)
    }
    throw err
  }
})()

if (args['--help']) {
  help({
    options: { ...flags, ...sharedFlags },
    usage: [`tailwindcss ${command} [options]`],
  })
  process.exit(0)
}

run(args)
