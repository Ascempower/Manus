/**
 * @fileoverview Rule to check that spaced function application
 * @author Matt DuVall <http://www.mattduvall.com>
 * @deprecated in ESLint v3.3.0
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&apos;../types&apos;).Rule.RuleModule} */
module.exports = {
	meta: {
		type: &quot;layout&quot;,

		docs: {
			description:
				&quot;Disallow spacing between function identifiers and their applications (deprecated)&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/no-spaced-func&quot;,
		},

		deprecated: {
			message: &quot;Formatting rules are being moved out of ESLint core.&quot;,
			url: &quot;https://eslint.org/blog/2016/08/eslint-v3.3.0-released/#deprecated-rules&quot;,
			deprecatedSince: &quot;3.3.0&quot;,
			availableUntil: &quot;10.0.0&quot;,
			replacedBy: [
				{
					message:
						&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;,
					url: &quot;https://eslint.style/guide/migration&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin-js&quot;,
						url: &quot;https://eslint.style/packages/js&quot;,
					},
					rule: {
						name: &quot;function-call-spacing&quot;,
						url: &quot;https://eslint.style/rules/js/function-call-spacing&quot;,
					},
				},
			],
		},

		fixable: &quot;whitespace&quot;,
		schema: [],

		messages: {
			noSpacedFunction:
				&quot;Unexpected space between function name and paren.&quot;,
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;

		/**
		 * Check if open space is present in a function name
		 * @param {ASTNode} node node to evaluate
		 * @returns {void}
		 * @private
		 */
		function detectOpenSpaces(node) {
			const lastCalleeToken = sourceCode.getLastToken(node.callee);
			let prevToken = lastCalleeToken,
				parenToken = sourceCode.getTokenAfter(lastCalleeToken);

			// advances to an open parenthesis.
			while (
				parenToken &&
				parenToken.range[1] < node.range[1] &&
				parenToken.value !== "("
			) {
				prevToken = parenToken;
				parenToken = sourceCode.getTokenAfter(parenToken);
			}

			// look for a space between the callee and the open paren
			if (
				parenToken &&
				parenToken.range[1] < node.range[1] &&
				sourceCode.isSpaceBetweenTokens(prevToken, parenToken)
			) {
				context.report({
					node,
					loc: lastCalleeToken.loc.start,
					messageId: "noSpacedFunction",
					fix(fixer) {
						return fixer.removeRange([
							prevToken.range[1],
							parenToken.range[0],
						]);
					},
				});
			}
		}

		return {
			CallExpression: detectOpenSpaces,
			NewExpression: detectOpenSpaces,
		};
	},
};
