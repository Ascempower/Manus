/**
 * @fileoverview Rule to enforce line breaks between arguments of a function call
 * @author Alexey Gonchar <https://github.com/finico>
 * @deprecated in ESLint v8.53.0
 */

&quot;use strict&quot;;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import(&apos;../types&apos;).Rule.RuleModule} */
module.exports = {
	meta: {
		deprecated: {
			message: &quot;Formatting rules are being moved out of ESLint core.&quot;,
			url: &quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;,
			deprecatedSince: &quot;8.53.0&quot;,
			availableUntil: &quot;10.0.0&quot;,
			replacedBy: [
				{
					message:
						&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;,
					url: &quot;https://eslint.style/guide/migration&quot;,
					plugin: {
						name: &quot;@stylistic/eslint-plugin-js&quot;,
						url: &quot;https://eslint.style/packages/js&quot;,
					},
					rule: {
						name: &quot;function-call-argument-newline&quot;,
						url: &quot;https://eslint.style/rules/js/function-call-argument-newline&quot;,
					},
				},
			],
		},
		type: &quot;layout&quot;,

		docs: {
			description:
				&quot;Enforce line breaks between arguments of a function call&quot;,
			recommended: false,
			url: &quot;https://eslint.org/docs/latest/rules/function-call-argument-newline&quot;,
		},

		fixable: &quot;whitespace&quot;,

		schema: [
			{
				enum: [&quot;always&quot;, &quot;never&quot;, &quot;consistent&quot;],
			},
		],

		messages: {
			unexpectedLineBreak: &quot;There should be no line break here.&quot;,
			missingLineBreak:
				&quot;There should be a line break after this argument.&quot;,
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;

		const checkers = {
			unexpected: {
				messageId: &quot;unexpectedLineBreak&quot;,
				check: (prevToken, currentToken) =>
					prevToken.loc.end.line !== currentToken.loc.start.line,
				createFix: (token, tokenBefore) => fixer =>
					fixer.replaceTextRange(
						[tokenBefore.range[1], token.range[0]],
						&quot; &quot;,
					),
			},
			missing: {
				messageId: &quot;missingLineBreak&quot;,
				check: (prevToken, currentToken) =>
					prevToken.loc.end.line === currentToken.loc.start.line,
				createFix: (token, tokenBefore) => fixer =>
					fixer.replaceTextRange(
						[tokenBefore.range[1], token.range[0]],
						&quot;\n&quot;,
					),
			},
		};

		/**
		 * Check all arguments for line breaks in the CallExpression
		 * @param {CallExpression} node node to evaluate
		 * @param {{ messageId: string, check: Function }} checker selected checker
		 * @returns {void}
		 * @private
		 */
		function checkArguments(node, checker) {
			for (let i = 1; i < node.arguments.length; i++) {
				const prevArgToken = sourceCode.getLastToken(
					node.arguments[i - 1],
				);
				const currentArgToken = sourceCode.getFirstToken(
					node.arguments[i],
				);

				if (checker.check(prevArgToken, currentArgToken)) {
					const tokenBefore = sourceCode.getTokenBefore(
						currentArgToken,
						{ includeComments: true },
					);

					const hasLineCommentBefore = tokenBefore.type === "Line";

					context.report({
						node,
						loc: {
							start: tokenBefore.loc.end,
							end: currentArgToken.loc.start,
						},
						messageId: checker.messageId,
						fix: hasLineCommentBefore
							? null
							: checker.createFix(currentArgToken, tokenBefore),
					});
				}
			}
		}

		/**
		 * Check if open space is present in a function name
		 * @param {CallExpression} node node to evaluate
		 * @returns {void}
		 * @private
		 */
		function check(node) {
			if (node.arguments.length < 2) {
				return;
			}

			const option = context.options[0] || "always";

			if (option === "never") {
				checkArguments(node, checkers.unexpected);
			} else if (option === "always") {
				checkArguments(node, checkers.missing);
			} else if (option === "consistent") {
				const firstArgToken = sourceCode.getLastToken(
					node.arguments[0],
				);
				const secondArgToken = sourceCode.getFirstToken(
					node.arguments[1],
				);

				if (
					firstArgToken.loc.end.line === secondArgToken.loc.start.line
				) {
					checkArguments(node, checkers.unexpected);
				} else {
					checkArguments(node, checkers.missing);
				}
			}
		}

		return {
			CallExpression: check,
			NewExpression: check,
		};
	},
};
